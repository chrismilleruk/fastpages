{
  
    
        "post0": {
            "title": "W&B - Evaluating Hyperparameter sweeps with W&B",
            "content": ". Note: This is my exploration of W&amp;B Sweeps . Evaluating Hyperparameter sweeps with W&amp;B . Sweeps enable us to try lots of different hyperparameters / config with our model and see which combination performs best. . We know how sweeps work on a fundamental level. Now let&#39;s use them with a real model and check the results. . Setup . Start out by installing the experiment tracking library and setting up your free W&amp;B account: . pip install wandb – Install the W&amp;B library | import wandb – Import the wandb library | . # WandB – Install the W&amp;B library %pip install wandb -q import wandb # from wandb.keras import WandbCallback . Explore The Simpsons Dataset . characters = glob.glob(&#39;simpsons-dataset/kaggle_simpson_testset/kaggle_simpson_testset/**&#39;) # characters = glob.glob(&#39;simpsons-dataset/simpsons_dataset/simpsons_dataset/*/**&#39;) plt.figure(figsize=(16,11)) plt.subplots_adjust(wspace=0, hspace=0.1) i = 0 for character in characters[:15]: img = cv2.imread(character) img = cv2.resize(img, (250, 250)) plt.subplot(3, 5, i+1) plt.title(character.split(&#39;testset/&#39;)[-1]) # plt.title(character.split(&#39;/&#39;)[-2]) plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) plt.axis(&#39;off&#39;) i += 1 . # Define the labels for the Simpsons characters we&#39;re detecting character_names = {0: &#39;abraham_grampa_simpson&#39;, 1: &#39;apu_nahasapeemapetilon&#39;, 2: &#39;bart_simpson&#39;, 3: &#39;charles_montgomery_burns&#39;, 4: &#39;chief_wiggum&#39;, 5: &#39;comic_book_guy&#39;, 6: &#39;edna_krabappel&#39;, 7: &#39;homer_simpson&#39;, 8: &#39;kent_brockman&#39;, 9: &#39;krusty_the_clown&#39;, 10: &#39;lenny_leonard&#39;, 11:&#39;lisa_simpson&#39;, 12: &#39;marge_simpson&#39;, 13: &#39;mayor_quimby&#39;,14:&#39;milhouse_van_houten&#39;, 15: &#39;moe_szyslak&#39;, 16: &#39;ned_flanders&#39;, 17: &#39;nelson_muntz&#39;, 18: &#39;principal_skinner&#39;, 19: &#39;sideshow_bob&#39;} img_size = 64 num_classes = 20 dir = &quot;simpsons-dataset/simpsons_dataset/simpsons_dataset&quot; # Load training data X_train = [] y_train = [] for label, name in character_names.items(): list_images = os.listdir(dir+&#39;/&#39;+name) for image_name in list_images: image = imageio.imread(dir+&#39;/&#39;+name+&#39;/&#39;+image_name) X_train.append(cv2.resize(image, (img_size,img_size))) y_train.append(label) X_train = np.array(X_train) y_train = np.array(y_train) # Split data for cross validation X_test = X_train[-100:] y_test = y_train[-100:] X_train = X_train[:-100] y_train = y_train[:-100] # Normalize the data X_train = X_train / 255.0 X_test = X_test / 255.0 # One hot encode the labels (neural nets only like numbers) y_train = np_utils.to_categorical(y_train, num_classes) y_test = np_utils.to_categorical(y_test, num_classes) . . len(X_train), len(y_train), len(X_test), len(y_test) . (19448, 19448, 100, 100) . plt.figure(figsize=(16,10)) plt.subplots_adjust(wspace=0, hspace=0.1) p = 1 for i in range(0, len(X_train), len(X_train)//14): img = X_train[i] label = character_names[y_train[i].argmax(0)] img = cv2.resize(img, (250, 250)) plt.subplot(3, 5, p) p += 1 plt.title(label) plt.imshow(img) plt.axis(&#39;off&#39;) . Run A Sweep . I ran a hyperparameter sweep in the weights and biases tool with 32 runs and you can view the report here: wandb.ai/chrismilleruk/reports/Exploring-W-B-Sweeps . Here you can see the bayesian algorithm gradually improved it&#39;s prediction of which combination of hyperparameters to attempt. . Here are all the hyperparameters laid out in an (interactive) visualisation. . A filtered view of the hyperparameters that yielded &gt;80% accuracy (with &gt;90% highlighted) allows some conclusions to be drawn if further sweeps are required. . Retrieve the best model from the W&amp;B sweep . We&#39;ll just go ahead and get the best model from all the epochs of all the runs in the sweep. . entity = &#39;sweep&#39; project = &#39;simpsons&#39; sweep_id = &quot;uqg7jmld&quot; # import wandb api = wandb.Api() sweep = api.sweep(entity + &quot;/&quot; + project + &quot;/&quot; + sweep_id) runs = sorted(sweep.runs, key=lambda run: run.summary.get(&quot;val_accuracy&quot;, 0), reverse=True) val_acc = runs[0].summary.get(&quot;val_accuracy&quot;, 0) print(f&quot;Best run {runs[0].name} with {val_acc * 100}% validation accuracy&quot;) runs[0].file(&quot;model-best.h5&quot;).download(replace=True) print(&quot;Best model saved to model-best.h5&quot;) . Best run gallant-sweep-26 with 99.00000095367432% validation accuracy Best model saved to model-best.h5 . Load the model . # Recreate the exact same model, including its weights and the optimizer model = tf.keras.models.load_model(&#39;model-best.h5&#39;) # Show the model architecture model.summary() . Model: &#34;sequential&#34; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d (Conv2D) (None, 64, 64, 32) 896 _________________________________________________________________ batch_normalization (BatchNo (None, 64, 64, 32) 128 _________________________________________________________________ dropout (Dropout) (None, 64, 64, 32) 0 _________________________________________________________________ conv2d_1 (Conv2D) (None, 64, 64, 64) 18496 _________________________________________________________________ batch_normalization_1 (Batch (None, 64, 64, 64) 256 _________________________________________________________________ max_pooling2d (MaxPooling2D) (None, 32, 32, 64) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 32, 32, 128) 73856 _________________________________________________________________ batch_normalization_2 (Batch (None, 32, 32, 128) 512 _________________________________________________________________ dropout_1 (Dropout) (None, 32, 32, 128) 0 _________________________________________________________________ conv2d_3 (Conv2D) (None, 32, 32, 128) 147584 _________________________________________________________________ batch_normalization_3 (Batch (None, 32, 32, 128) 512 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 16, 16, 128) 0 _________________________________________________________________ conv2d_4 (Conv2D) (None, 16, 16, 256) 295168 _________________________________________________________________ batch_normalization_4 (Batch (None, 16, 16, 256) 1024 _________________________________________________________________ dropout_2 (Dropout) (None, 16, 16, 256) 0 _________________________________________________________________ conv2d_5 (Conv2D) (None, 16, 16, 256) 590080 _________________________________________________________________ batch_normalization_5 (Batch (None, 16, 16, 256) 1024 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 8, 8, 256) 0 _________________________________________________________________ conv2d_6 (Conv2D) (None, 8, 8, 512) 1180160 _________________________________________________________________ batch_normalization_6 (Batch (None, 8, 8, 512) 2048 _________________________________________________________________ dropout_3 (Dropout) (None, 8, 8, 512) 0 _________________________________________________________________ conv2d_7 (Conv2D) (None, 8, 8, 512) 2359808 _________________________________________________________________ batch_normalization_7 (Batch (None, 8, 8, 512) 2048 _________________________________________________________________ max_pooling2d_3 (MaxPooling2 (None, 4, 4, 512) 0 _________________________________________________________________ conv2d_8 (Conv2D) (None, 4, 4, 1024) 4719616 _________________________________________________________________ batch_normalization_8 (Batch (None, 4, 4, 1024) 4096 _________________________________________________________________ dropout_4 (Dropout) (None, 4, 4, 1024) 0 _________________________________________________________________ conv2d_9 (Conv2D) (None, 4, 4, 1024) 9438208 _________________________________________________________________ batch_normalization_9 (Batch (None, 4, 4, 1024) 4096 _________________________________________________________________ max_pooling2d_4 (MaxPooling2 (None, 2, 2, 1024) 0 _________________________________________________________________ flatten (Flatten) (None, 4096) 0 _________________________________________________________________ dense (Dense) (None, 512) 2097664 _________________________________________________________________ batch_normalization_10 (Batc (None, 512) 2048 _________________________________________________________________ dropout_5 (Dropout) (None, 512) 0 _________________________________________________________________ dense_1 (Dense) (None, 20) 10260 ================================================================= Total params: 20,949,588 Trainable params: 20,940,692 Non-trainable params: 8,896 _________________________________________________________________ . . Make some predictions with the model . def get_prediction(x, y): # Resize image and normalize it pic = cv2.resize(x, (64, 64)).astype(&#39;float32&#39;) if pic.max() &gt; 1.: pic = pic / 255. # Get predictions for the character prediction = model.predict(pic.reshape(1, 64, 64, 3))[0] # Get true name of the character character = character_names[y] name = character.split(&#39;_&#39;)[0].title() # Format predictions to string to overlay on image text = sorted([&#39;{:s} : {:.1f}%&#39;.format(character_names[k].split(&#39;_&#39;)[0].title(), 100*v) for k,v in enumerate(prediction)], key=lambda x:float(x.split(&#39;:&#39;)[1].split(&#39;%&#39;)[0]), reverse=True)[:3] # Upscale original image (expecting a 0-255 range here) img = cv2.resize(x, (352, 352)) if np.issubdtype(img.dtype, &#39;float&#39;): img = (img * 255).astype(&#39;uint8&#39;) # Create background to overlay text on cv2.rectangle(img, (0,260),(215,352),(255,255,255), -1) # Add text to image font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(img, &#39;Name : %s&#39; % name, (10, 280), font, 0.7,(73,79,183), 2, cv2.LINE_AA) for k, t in enumerate(text): color = (10,100,10) if name in t else (80,0,0) cv2.putText(img, t, (10, 300+k*18), font, 0.65, color, 2, cv2.LINE_AA) title = &quot;%s: %s&quot; % (name, text[0]) return img, title . . Visualisation of performance against the validation data . This should be very good since it was used during training. This is also how we measured the success of the model vs other models. The best run was had a 99% validation accuracy so anything less than that would be a problem here. . plt.figure(figsize=(18,8)) plt.subplots_adjust(wspace=0, hspace=0.1) p = 1 for i in range(0, len(X_test), len(X_test) // 9): plt.subplot(2, 5, p) p += 1 x = X_test[i] y = y_test[i].argmax() (img, label) = get_prediction(x, y) plt.imshow( img ) plt.title( label ) plt.axis(&#39;off&#39;) . The predictions are all great. Very confident and correct. . But there is a problem here. While the predictions are all great it looks like the validation data contains only pictures of Sideshow Bob. . This is a problem that needs to be fixed but how will the model perform against a dataset it&#39;s never seen before? . Visualize predictions against the kaggle testset . This dataset was never used during training and so provides a view of the model performance under exam conditions. . def predict_test(): predicted_images = [] for i in range(20): character = character_names[i] # Read in a character image from the test dataset image = cv2.imread(np.random.choice([k for k in glob.glob(&#39;simpsons-dataset/kaggle_simpson_testset/kaggle_simpson_testset/*.*&#39;) if character in k])) # print(image.shape) image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) (img, title) = get_prediction(image, i) predicted_images.append((img, title)) return predicted_images . . predicted = predict_test() plt.figure(figsize=(18,18)) plt.subplots_adjust(wspace=0, hspace=0) p = 1 for i in range(0, len(predicted)): img = predicted[i][0] label = predicted[i][1] img = cv2.resize(img, (250, 250)) plt.subplot(4, 5, p) p += 1 plt.title(label) plt.imshow(img) plt.axis(&#39;off&#39;) . Not bad considering the flaw in our methodology. I&#39;ve run this a few times now and we occasionally drop one or two for each batch of 25. It&#39;s probably around 90% at a guess. . Let&#39;s check the whole kaggle test set. . Evaluate entire test set . testset = glob.glob(&#39;simpsons-dataset/kaggle_simpson_testset/kaggle_simpson_testset/*.jpg&#39;) img_size = 64 x_testset = [] y_testset = [] for i in range(len(testset)): path = testset[i] image = imageio.imread(path) image = cv2.resize(image, (img_size,img_size)) if image.shape != (img_size, img_size, 3): continue filename = path.split(&#39;testset/&#39;)[-1] names = [k for k, v in character_names.items() if v in filename] if not names: continue x_testset.append(image) y_testset.append(names[0]) x_testset = np.array(x_testset) y_testset = np.array(y_testset) # Normalise image data x_testset = x_testset / 255 print(&#39;Making model predictions for %d images&#39; % len(x_testset)) %time prediction = model.predict(x_testset) predictions = prediction.argmax(1) print(&#39; nCompare first 24 predictions:&#39;) print(predictions[:24]) print(y_testset[:24]) arr = predictions == y_testset print(&#39; nAccuracy&#39;, np.sum(arr), &#39;/&#39;, len(arr)) print(np.sum(arr) / len(arr) * 100, &#39;%&#39;) . Making model predictions for 938 images CPU times: user 1min, sys: 222 ms, total: 1min 1s Wall time: 31.1 s Compare first 24 predictions: [11 17 10 19 4 15 9 17 4 19 15 8 3 0 1 17 14 17 11 8 4 1 15 6] [11 17 10 19 4 15 9 10 4 0 15 8 3 0 1 10 14 17 11 8 4 1 15 6] Accuracy 806 / 938 85.9275053304904 % . Confusion Matrix . confusion = confusion_matrix(y_testset, predictions) labels = list(character_names.values()) plot_conf_matrix(confusion, labels, &quot;Confusion Matrix for best model in W&amp;B sweep&quot;) . Results . 85% accuracy across 938 test images. . Not bad, but could be improved. . We have some paths to make this better: . Correct the flaw in the validation data. | Run a broad, then narrow sweep | Evaluate again. |",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/wandb/tf/hyperparameters/2021/01/24/Eval_Hyperparameter_Sweeps_with_W&B.html",
            "relUrl": "/jupyter/ai/wandb/tf/hyperparameters/2021/01/24/Eval_Hyperparameter_Sweeps_with_W&B.html",
            "date": " • Jan 24, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "W&B - Introduction to Hyperparameter Sweeps",
            "content": ". Note: Based on a notebook from W&amp;B Sweeps . Introduction to Hyperparameter Sweeps &#8211; A Battle Royale To Find The Best Model In 3 Steps . Searching through high dimensional hyperparameter spaces to find the most performant model can get unwieldy very fast. Hyperparameter sweeps provide an organized and efficient way to conduct a battle royale of models and pick the most accurate model. They enable this by automatically searching through combinations of hyperparameter values (e.g. learning rate, batch size, number of hidden layers, optimizer type) to find the most optimal values. . In this tutorial we&#39;ll see how you can run sophisticated hyperparameter sweeps in 3 easy steps using Weights and Biases. . We&#39;ll train a plethora of convolutional neural networks and our battle royale will surface the model that classifies Simpsons characters with the highest accuracy. We&#39;ll work with this dataset from Kaggle. . We&#39;ll also use Weights &amp; Biases to log models metrics, inspect performance and share findings about the best architecture for the network. In this example we&#39;re using Google Colab as a convenient hosted environment, but you can run your own training scripts from anywhere and visualize metrics with W&amp;B&#39;s experiment tracking tool. . Getting Started . Click &quot;Open in playground&quot; to create a copy of this notebook for yourself. | Save a copy in Google Drive for yourself. | To enable a GPU, please click Edit &gt; Notebook Settings. Change the &quot;hardware accelerator&quot; to GPU. | Step through each section below, pressing play on the code blocks to run the cells. | Results will be logged to a shared W&amp;B project page. . . Sweeps: An Overview . Running a hyperparameter sweep with Weights &amp; Biases is very easy. There are just 3 simple steps: . Define the sweep: we do this by creating a dictionary or a YAML file that specifies the parameters to search through, the search strategy, the optimization metric et all. . | Initialize the sweep: with one line of code we initialize the sweep and pass in the dictionary of sweep configurations: sweep_id = wandb.sweep(sweep_config) . | Run the sweep agent: also accomplished with one line of code, we call wandb.agent() and pass the sweep_id to run, along with a function that defines your model architecture and trains it: wandb.agent(sweep_id, function=train) . | And voila! That&#39;s all there is to running a hyperparameter sweep! In the notebook below, we&#39;ll walk through these 3 steps in more detail. . You can also find the full sweeps docs with all configuration options here. . We highly encourage you to fork this notebook, tweak the parameters, or try the model with your own dataset! . Let&#39;s Dive In! . You know how sweeps work on a fundamental level. Now let&#39;s use them with a real model. . import pandas as pd import numpy as np import seaborn as sns from sklearn import model_selection from sklearn.model_selection import train_test_split, learning_curve, KFold, cross_val_score, StratifiedKFold # Models import tensorflow from tensorflow import keras from keras import backend as K from keras import regularizers from keras.models import Sequential, model_from_json from keras.preprocessing.image import ImageDataGenerator from keras.utils import np_utils from keras.layers import Dense, Flatten, Conv2D, BatchNormalization, Dropout, MaxPooling2D, Activation from keras.optimizers import RMSprop, SGD, Adam, Nadam from keras import callbacks from keras.callbacks import ReduceLROnPlateau, ModelCheckpoint, Callback, EarlyStopping # Image Libraries from PIL import Image, ImageFilter, ImageStat import random random.seed(42) import imageio import PIL import os import itertools import glob import cv2, glob import matplotlib.pyplot as plt from mpl_toolkits.axes_grid1 import AxesGrid %matplotlib inline # Ignore excessive warnings os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;3&#39; import tensorflow as tf tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR) . The default version of TensorFlow in Colab will soon switch to TensorFlow 2.x. We recommend you upgrade now or ensure your notebook will continue to use TensorFlow 1.x via the %tensorflow_version 1.x magic: more info. . Using TensorFlow backend. . Setup . Start out by installing the experiment tracking library and setting up your free W&amp;B account: . pip install wandb – Install the W&amp;B library | import wandb – Import the wandb library | . %pip install wandb -q import wandb from wandb.keras import WandbCallback . |████████████████████████████████| 1.3MB 9.4MB/s |████████████████████████████████| 256kB 74.3MB/s |████████████████████████████████| 460kB 70.5MB/s |████████████████████████████████| 92kB 14.3MB/s |████████████████████████████████| 92kB 12.6MB/s |████████████████████████████████| 102kB 13.8MB/s |████████████████████████████████| 184kB 70.5MB/s |████████████████████████████████| 71kB 11.6MB/s Building wheel for shortuuid (setup.py) ... done Building wheel for watchdog (setup.py) ... done Building wheel for gql (setup.py) ... done Building wheel for subprocess32 (setup.py) ... done Building wheel for pathtools (setup.py) ... done . Explore The Simpsons Dataset . !git clone https://github.com/lavanyashukla/simpsons-dataset.git . Cloning into &#39;simpsons-dataset&#39;... remote: Enumerating objects: 21934, done. remote: Total 21934 (delta 0), reused 0 (delta 0), pack-reused 21934 Receiving objects: 100% (21934/21934), 590.28 MiB | 37.97 MiB/s, done. Resolving deltas: 100% (1/1), done. Checking out files: 100% (42860/42860), done. . characters = glob.glob(&#39;simpsons-dataset/kaggle_simpson_testset/kaggle_simpson_testset/**&#39;) plt.figure(figsize=(10,10)) plt.subplots_adjust(wspace=0, hspace=0) i = 0 for character in characters[:25]: img = cv2.imread(character) img = cv2.resize(img, (250, 250)) plt.axis(&#39;off&#39;) plt.subplot(5, 5, i+1) #.set_title(l) plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) i += 1 . character_names = {0: &#39;abraham_grampa_simpson&#39;, 1: &#39;apu_nahasapeemapetilon&#39;, 2: &#39;bart_simpson&#39;, 3: &#39;charles_montgomery_burns&#39;, 4: &#39;chief_wiggum&#39;, 5: &#39;comic_book_guy&#39;, 6: &#39;edna_krabappel&#39;, 7: &#39;homer_simpson&#39;, 8: &#39;kent_brockman&#39;, 9: &#39;krusty_the_clown&#39;, 10: &#39;lenny_leonard&#39;, 11:&#39;lisa_simpson&#39;, 12: &#39;marge_simpson&#39;, 13: &#39;mayor_quimby&#39;,14:&#39;milhouse_van_houten&#39;, 15: &#39;moe_szyslak&#39;, 16: &#39;ned_flanders&#39;, 17: &#39;nelson_muntz&#39;, 18: &#39;principal_skinner&#39;, 19: &#39;sideshow_bob&#39;} img_size = 64 num_classes = 20 dir = &quot;simpsons-dataset/simpsons_dataset/simpsons_dataset&quot; # Load training data X_train = [] y_train = [] for label, name in character_names.items(): list_images = os.listdir(dir+&#39;/&#39;+name) for image_name in list_images: image = imageio.imread(dir+&#39;/&#39;+name+&#39;/&#39;+image_name) X_train.append(cv2.resize(image, (img_size,img_size))) y_train.append(label) X_train = np.array(X_train) y_train = np.array(y_train) # Split data for cross validation X_train = X_train[:1000] y_train = y_train[:1000] X_test = X_train[-100:] y_test = y_train[-100:] # Normalize the data X_train = X_train / 255.0 X_test = X_test / 255.0 # One hot encode the labels (neural nets only like numbers) y_train = np_utils.to_categorical(y_train, num_classes) y_test = np_utils.to_categorical(y_test, num_classes) . Run A Sweep . As you&#39;ll recall there are just 3 simple steps to running a sweep: . 1. Define the sweep . 2. Initialize the sweep . 3. Run the sweep agent . Let&#39;s walk through each step in more detail. . . 1. Define the Sweep . Weights &amp; Biases sweeps give you powerful levers to configure your sweeps exactly how you want them, with just a few lines of code. The sweeps config can be defined as a dictionary or a YAML file. . Let&#39;s walk through some of them together: . Metric – This is the metric the sweeps are attempting to optimize. Metrics can take a name (this metric should be logged by your training script) and a goal (maximize or minimize). | Search Strategy – Specified using the &#39;method&#39; variable. We support several different search strategies with sweeps. Grid Search – Iterates over every combination of hyperparameter values. | Random Search – Iterates over randomly chosen combinations of hyperparameter values. | Bayesian Search – Creates a probabilistic model that maps hyperparameters to probability of a metric score, and chooses parameters with high probability of improving the metric. The objective of Bayesian optimization is to spend more time in picking the hyperparameter values, but in doing so trying out fewer hyperparameter values. | . | Stopping Criteria – The strategy for determining when to kill off poorly peforming runs, and try more combinations faster. We offer several custom scheduling algorithms like HyperBand and Envelope. | Parameters – A dictionary containing the hyperparameter names, and discreet values, max and min values or distributions from which to pull their values to sweep over. | . You can find a list of all configuration options here. . A Note To Advanced Users . Advanced users can modify sweep algorithms or write their own based on the W&amp;B base classes wandb.sweeps.base.Search and wandb.sweeps.base.EarlyTerminate, which you can find in our open source client library. . They can also create a local controller, which lets users take full control of search and stopping criteria, inspect and modify the code in order to debug issues as well as develop new features which can be incorporated into the cloud service. . sweep_config = { &#39;method&#39;: &#39;random&#39;, #grid, random &#39;metric&#39;: { &#39;name&#39;: &#39;accuracy&#39;, &#39;goal&#39;: &#39;maximize&#39; }, &#39;parameters&#39;: { &#39;epochs&#39;: { &#39;values&#39;: [10, 20, 50] }, &#39;dropout&#39;: { &#39;values&#39;: [0.3, 0.4, 0.5] }, &#39;conv_layer_size&#39;: { &#39;values&#39;: [16, 32, 64] }, &#39;encoder_size&#39;: { &#39;values&#39;: [128, 256, 512] }, &#39;decoder_size&#39;: { &#39;values&#39;: [256, 512, 1024] }, &#39;weight_decay&#39;: { &#39;values&#39;: [0.0005, 0.005, 0.05] }, &#39;learning_rate&#39;: { &#39;values&#39;: [1e-2, 1e-3, 1e-4, 3e-4, 3e-5, 1e-5] }, &#39;optimizer&#39;: { &#39;values&#39;: [&#39;adam&#39;, &#39;nadam&#39;, &#39;sgd&#39;, &#39;rmsprop&#39;] }, &#39;activation&#39;: { &#39;values&#39;: [&#39;relu&#39;, &#39;elu&#39;, &#39;selu&#39;, &#39;softmax&#39;] }, &#39;layer&#39;: { &#39;values&#39;: [&#39;LSTM&#39;, &#39;GRU&#39;] } } } . 2. Initialize the Sweep . # Arguments: # – sweep_config: the sweep config dictionary defined above # – entity: Set the username for the sweep # – project: Set the project name for the sweep sweep_id = wandb.sweep(sweep_config, entity=&quot;sweep&quot;, project=&quot;simpsons&quot;) . Create sweep with ID: bfozkh0e Sweep URL: https://app.wandb.ai/sweep/simpsons/sweeps/bfozkh0e . Define Your Neural Network . Before we can run the sweep, let&#39;s define a function that creates and trains our neural network. . In the function below, we define a simplified version of a VGG19 model in Keras, and add the following lines of code to log models metrics, visualize performance and output and track our experiments easily: . wandb.init() – Initialize a new W&amp;B run. Each run is single execution of the training script. | wandb.config – Save all your hyperparameters in a config object. This lets you use our app to sort and compare your runs by hyperparameter values. | callbacks=[WandbCallback()] – Fetch all layer dimensions, model parameters and log them automatically to your W&amp;B dashboard. | wandb.log() – Logs custom objects – these can be images, videos, audio files, HTML, plots, point clouds etc. Here we use wandb.log to log images of Simpson characters overlaid with actual and predicted labels. | . def train(): # Default values for hyper-parameters we&#39;re going to sweep over config_defaults = { &#39;epochs&#39;: 2, &#39;batch_size&#39;: 128, &#39;weight_decay&#39;: 0.0005, &#39;learning_rate&#39;: 1e-3, &#39;activation&#39;: &#39;relu&#39;, &#39;optimizer&#39;: &#39;nadam&#39;, &#39;seed&#39;: 42 } # Initialize a new wandb run wandb.init(config=config_defaults) # Config is a variable that holds and saves hyperparameters and inputs config = wandb.config # Determine input shape input_shape = (X_train.shape[1], X_train.shape[2], 3) # Define the model architecture - This is a simplified version of the VGG19 architecture model = Sequential() # Set of Conv2D, Conv2D, MaxPooling2D layers with 32 and 64 filters model.add(Conv2D(filters = 32, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.3)) model.add(Conv2D(filters = 64, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(MaxPooling2D(pool_size=(2, 2))) # Another set of Conv2D, Conv2D, MaxPooling2D layers with 128 filters model.add(Conv2D(filters = 128, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(filters = 128, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(MaxPooling2D(pool_size=(2, 2))) # Another set of Conv2D, Conv2D, MaxPooling2D layers with 256 filters model.add(Conv2D(filters = 256, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(filters = 256, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(MaxPooling2D(pool_size=(2, 2))) # Another set of Conv2D, Conv2D, MaxPooling2D layers with 512 filters model.add(Conv2D(filters = 512, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(filters = 512, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(MaxPooling2D(pool_size=(2, 2))) # Another set of Conv2D, Conv2D, MaxPooling2D layers with 512 filters model.add(Conv2D(filters = 1024, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(filters = 1024, kernel_size = (3, 3), padding = &#39;same&#39;, activation =&#39;relu&#39;, input_shape = input_shape, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(MaxPooling2D(pool_size=(2, 2))) # Flatten model.add(Flatten()) model.add(Dense(512, activation =&#39;relu&#39;, kernel_regularizer=regularizers.l2(config.weight_decay))) model.add(BatchNormalization()) model.add(Dropout(0.5)) model.add(Dense(num_classes, activation = &quot;softmax&quot;)) # Define the optimizer if config.optimizer==&#39;sgd&#39;: optimizer = SGD(lr=config.learning_rate, decay=1e-5, momentum=0.9, nesterov=True) elif config.optimizer==&#39;rmsprop&#39;: optimizer = RMSprop(lr=config.learning_rate, decay=1e-5) elif config.optimizer==&#39;adam&#39;: optimizer = Adam(lr=config.learning_rate, beta_1=0.9, beta_2=0.999, clipnorm=1.0) elif config.optimizer==&#39;nadam&#39;: optimizer = Nadam(lr=config.learning_rate, beta_1=0.9, beta_2=0.999, clipnorm=1.0) model.compile(loss = &quot;categorical_crossentropy&quot;, optimizer = optimizer, metrics=[&#39;accuracy&#39;]) #data augmentation datagen = ImageDataGenerator( featurewise_center=False, # set input mean to 0 over the dataset samplewise_center=False, # set each sample mean to 0 featurewise_std_normalization=False, # divide inputs by std of the dataset samplewise_std_normalization=False, # divide each input by its std zca_whitening=False, # apply ZCA whitening rotation_range=15, # randomly rotate images in the range (degrees, 0 to 180) width_shift_range=0.1, # randomly shift images horizontally (fraction of total width) height_shift_range=0.1, # randomly shift images vertically (fraction of total height) horizontal_flip=True, # randomly flip images vertical_flip=False) # randomly flip images # (std, mean, and principal components if ZCA whitening is applied). datagen.fit(X_train) model.fit_generator(datagen.flow(X_train, y_train, batch_size=config.batch_size), steps_per_epoch=len(X_train) / 32, epochs=config.epochs, validation_data=(X_test, y_test), callbacks=[WandbCallback(data_type=&quot;image&quot;, validation_data=(X_test, y_test), labels=character_names), keras.callbacks.EarlyStopping(patience=10, restore_best_weights=True)]) predicted_images = [] for i in range(20): character = character_names[i] # Read in a character image from the test dataset image = cv2.imread(np.random.choice([k for k in glob.glob(&#39;simpsons-dataset/kaggle_simpson_testset/kaggle_simpson_testset/*.*&#39;) if character in k])) img = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Resize image and normalize it pic = cv2.resize(image, (64, 64)).astype(&#39;float32&#39;) / 255. # Get predictions for the character prediction = model.predict(pic.reshape(1, 64, 64,3))[0] # Get true name of the character name = character.split(&#39;_&#39;)[0].title() # Format predictions to string to overlay on image text = sorted([&#39;{:s} : {:.1f}%&#39;.format(character_names[k].split(&#39;_&#39;)[0].title(), 100*v) for k,v in enumerate(prediction)], key=lambda x:float(x.split(&#39;:&#39;)[1].split(&#39;%&#39;)[0]), reverse=True)[:3] # Upscale image img = cv2.resize(img, (352, 352)) # Create background to overlay text on cv2.rectangle(img, (0,260),(215,352),(255,255,255), -1) # Add text to image font = cv2.FONT_HERSHEY_DUPLEX cv2.putText(img, &#39;True Name : %s&#39; % name, (10, 280), font, 0.7,(73,79,183), 2, cv2.LINE_AA) for k, t in enumerate(text): cv2.putText(img, t, (10, 300+k*18), font, 0.65,(0,0,0), 2, cv2.LINE_AA) # Add predicted image from test dataset with annotations to array predicted_images.append(wandb.Image(img, caption=&quot;Actual: %s&quot; % name)) # Log images from test set to wandb automatically, along with predicted and true labels by passing pytorch tensors with image data into wandb.Image wandb.log({&quot;predictions&quot;: predicted_images}) . 3. Run the sweep agent . # Arguments: # – sweep_id: the sweep_id to run - this was returned above by wandb.sweep() # – function: function that defines your model architecture and trains it wandb.agent(sweep_id, train) . wandb: Agent Starting Run: qhzyiysj with config: batch_size: 128 epochs: 100 learning_rate: 0.001 optimizer: sgd weight_decay: 0.05 wandb: Agent Started Run: qhzyiysj . Logging results to Weights &amp; Biases (Documentation). Project page: https://app.wandb.ai/sweep/simpsons Sweep page: https://app.wandb.ai/sweep/simpsons/sweeps/bfozkh0e Run page: https://app.wandb.ai/sweep/simpsons/runs/qhzyiysj Epoch 1/100 32/31 [==============================] - 18s 571ms/step - loss: 208.1772 - acc: 0.1782 - val_loss: 202.2435 - val_acc: 0.2900 Epoch 2/100 32/31 [==============================] - 8s 263ms/step - loss: 195.4176 - acc: 0.6672 - val_loss: 189.9604 - val_acc: 0.5700 Epoch 3/100 32/31 [==============================] - 8s 263ms/step - loss: 182.3787 - acc: 0.9039 - val_loss: 177.9252 - val_acc: 0.6500 Epoch 4/100 32/31 [==============================] - 8s 266ms/step - loss: 170.7165 - acc: 0.9417 - val_loss: 170.7456 - val_acc: 0.1800 Epoch 5/100 32/31 [==============================] - 8s 263ms/step - loss: 159.8565 - acc: 0.9722 - val_loss: 159.6783 - val_acc: 0.2200 Epoch 6/100 32/31 [==============================] - 8s 263ms/step - loss: 149.8787 - acc: 0.9744 - val_loss: 147.8720 - val_acc: 0.3800 Epoch 7/100 32/31 [==============================] - 8s 263ms/step - loss: 140.5229 - acc: 0.9801 - val_loss: 138.6446 - val_acc: 0.3300 Epoch 8/100 32/31 [==============================] - 8s 262ms/step - loss: 131.7099 - acc: 0.9859 - val_loss: 130.0943 - val_acc: 0.3300 Epoch 9/100 32/31 [==============================] - 8s 264ms/step - loss: 123.5052 - acc: 0.9865 - val_loss: 120.9473 - val_acc: 0.4800 Epoch 10/100 32/31 [==============================] - 8s 263ms/step - loss: 115.8305 - acc: 0.9851 - val_loss: 114.8688 - val_acc: 0.1800 Epoch 11/100 32/31 [==============================] - 8s 264ms/step - loss: 108.6039 - acc: 0.9881 - val_loss: 106.6842 - val_acc: 0.4300 Epoch 12/100 23/31 [=====================&gt;........] - ETA: 2s - loss: 102.7420 - acc: 0.9903 . Visualize Predictions Live . Project Overview . Check out the project page to see your results in the shared project. | Press &#39;option+space&#39; to expand the runs table, comparing all the results from everyone who has tried this script. | Click on the name of a run to dive in deeper to that single run on its own run page. | . Visualize Sweep Results . Use a parallel coordinates chart to see which hyperparameter values led to the best accuracy. . . We can tweak the slides in the parallel co-ordinates chart to only view the runs that led to the best accuracy values. This can help us hone in on ranges of hyperparameter values to sweep over next. . . Visualize Performance . Click through to a single run to see more details about that run. For example, on this run page you can see the performance metrics I logged when I ran this script. . . Visualize Predictions . You can visualize predictions made at everystep by clicking on the Media tab. . . Review Code . The overview tab picks up a link to the code. In this case, it&#39;s a link to the Google Colab. If you&#39;re running a script from a git repo, we&#39;ll pick up the SHA of the latest git commit and give you a link to that version of the code in your own GitHub repo. . . Visualize System Metrics . The System tab on the runs page lets you visualize how resource efficient your model was. It lets you monitor the GPU, memory, CPU, disk, and network usage in one spot. . . Next Steps . As you can see running sweeps is super easy! We highly encourage you to fork this notebook, tweak the parameters, or try the model with your own dataset! . More about Weights &amp; Biases . We&#39;re always free for academics and open source projects. Email carey@wandb.com with any questions or feature suggestions. Here are some more resources: . Documentation - Python docs | Gallery - example reports in W&amp;B | Articles - blog posts and tutorials | Community - join our Slack community forum |",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/wandb/tf/hyperparameters/2021/01/22/Intro_to_Hyperparameter_Sweeps_with_W&B.html",
            "relUrl": "/jupyter/ai/wandb/tf/hyperparameters/2021/01/22/Intro_to_Hyperparameter_Sweeps_with_W&B.html",
            "date": " • Jan 22, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Fast.ai - Image Classification",
            "content": "[[chapter_pet_breeds]] . Warning: This is just my notes from the excellent fast.ai MOOC which you can find here . Now that you understand what deep learning is, what it&#39;s for, and how to create and deploy a model, it&#39;s time for us to go deeper! In an ideal world deep learning practitioners wouldn&#39;t have to know every detail of how things work under the hood… But as yet, we don&#39;t live in an ideal world. The truth is, to make your model really work, and work reliably, there are a lot of details you have to get right, and a lot of details that you have to check. This process requires being able to look inside your neural network as it trains, and as it makes predictions, find possible problems, and know how to fix them. . So, from here on in the book we are going to do a deep dive into the mechanics of deep learning. What is the architecture of a computer vision model, an NLP model, a tabular model, and so on? How do you create an architecture that matches the needs of your particular domain? How do you get the best possible results from the training process? How do you make things faster? What do you have to change as your datasets change? . We will start by repeating the same basic applications that we looked at in the first chapter, but we are going to do two things: . Make them better. | Apply them to a wider variety of types of data. | . In order to do these two things, we will have to learn all of the pieces of the deep learning puzzle. This includes different types of layers, regularization methods, optimizers, how to put layers together into architectures, labeling techniques, and much more. We are not just going to dump all of these things on you, though; we will introduce them progressively as needed, to solve actual problems related to the projects we are working on. . From Dogs and Cats to Pet Breeds . In our very first model we learned how to classify dogs versus cats. Just a few years ago this was considered a very challenging task—but today, it&#39;s far too easy! We will not be able to show you the nuances of training models with this problem, because we get a nearly perfect result without worrying about any of the details. But it turns out that the same dataset also allows us to work on a much more challenging problem: figuring out what breed of pet is shown in each image. . In &lt;&gt; we presented the applications as already-solved problems. But this is not how things work in real life. We start with some dataset that we know nothing about. We then have to figure out how it is put together, how to extract the data we need from it, and what that data looks like. For the rest of this book we will be showing you how to solve these problems in practice, including all of the intermediate steps necessary to understand the data that you are working with and test your modeling as you go.&lt;/p&gt; We already downloaded the Pet dataset, and we can get a path to this dataset using the same code as in &lt;&gt;:&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; from fastai.vision.all import * path = untar_data(URLs.PETS) . Now if we are going to understand how to extract the breed of each pet from each image we&#39;re going to need to understand how this data is laid out. Such details of data layout are a vital piece of the deep learning puzzle. Data is usually provided in one of these two ways: . Individual files representing items of data, such as text documents or images, possibly organized into folders or with filenames representing information about those items | A table of data, such as in CSV format, where each row is an item which may include filenames providing a connection between the data in the table and data in other formats, such as text documents and images | . There are exceptions to these rules—particularly in domains such as genomics, where there can be binary database formats or even network streams—but overall the vast majority of the datasets you&#39;ll work with will use some combination of these two formats. . To see what is in our dataset we can use the ls method: . path.ls() . (#2) [Path(&#39;images&#39;),Path(&#39;annotations&#39;)] . We can see that this dataset provides us with images and annotations directories. The website for the dataset tells us that the annotations directory contains information about where the pets are rather than what they are. In this chapter, we will be doing classification, not localization, which is to say that we care about what the pets are, not where they are. Therefore, we will ignore the annotations directory for now. So, let&#39;s have a look inside the images directory: . (path/&quot;images&quot;).ls() . (#7393) [Path(&#39;images/american_bulldog_146.jpg&#39;),Path(&#39;images/japanese_chin_12.jpg&#39;),Path(&#39;images/Sphynx_247.jpg&#39;),Path(&#39;images/beagle_158.jpg&#39;),Path(&#39;images/beagle_76.jpg&#39;),Path(&#39;images/shiba_inu_207.jpg&#39;),Path(&#39;images/Siamese_56.jpg&#39;),Path(&#39;images/keeshond_194.jpg&#39;),Path(&#39;images/miniature_pinscher_89.jpg&#39;),Path(&#39;images/leonberger_42.jpg&#39;)...] . Most functions and methods in fastai that return a collection use a class called L. L can be thought of as an enhanced version of the ordinary Python list type, with added conveniences for common operations. For instance, when we display an object of this class in a notebook it appears in the format shown there. The first thing that is shown is the number of items in the collection, prefixed with a #. You&#39;ll also see in the preceding output that the list is suffixed with an ellipsis. This means that only the first few items are displayed—which is a good thing, because we would not want more than 7,000 filenames on our screen! . By examining these filenames, we can see how they appear to be structured. Each filename contains the pet breed, and then an underscore (_), a number, and finally the file extension. We need to create a piece of code that extracts the breed from a single Path. Jupyter notebooks make this easy, because we can gradually build up something that works, and then use it for the entire dataset. We do have to be careful to not make too many assumptions at this point. For instance, if you look carefully you may notice that some of the pet breeds contain multiple words, so we cannot simply break at the first _ character that we find. To allow us to test our code, let&#39;s pick out one of these filenames: . fname = (path/&quot;images&quot;).ls()[0] . The most powerful and flexible way to extract information from strings like this is to use a regular expression, also known as a regex. A regular expression is a special string, written in the regular expression language, which specifies a general rule for deciding if another string passes a test (i.e., &quot;matches&quot; the regular expression), and also possibly for plucking a particular part or parts out of that other string. . In this case, we need a regular expression that extracts the pet breed from the filename. . We do not have the space to give you a complete regular expression tutorial here, but there are many excellent ones online and we know that many of you will already be familiar with this wonderful tool. If you&#39;re not, that is totally fine—this is a great opportunity for you to rectify that! We find that regular expressions are one of the most useful tools in our programming toolkit, and many of our students tell us that this is one of the things they are most excited to learn about. So head over to Google and search for &quot;regular expressions tutorial&quot; now, and then come back here after you&#39;ve had a good look around. The book&#39;s website also provides a list of our favorites. . a:Not only are regular expressions dead handy, but they also have interesting roots. They are &quot;regular&quot; because they were originally examples of a &quot;regular&quot; language, the lowest rung within the Chomsky hierarchy, a grammar classification developed by linguist Noam Chomsky, who also wrote Syntactic Structures, the pioneering work searching for the formal grammar underlying human language. This is one of the charms of computing: it may be that the hammer you reach for every day in fact came from a spaceship. When you are writing a regular expression, the best way to start is just to try it against one example at first. Let&#39;s use the findall method to try a regular expression against the filename of the fname object: . re.findall(r&#39;(.+)_ d+.jpg$&#39;, fname.name) . [&#39;american_bulldog&#39;] . This regular expression plucks out all the characters leading up to the last underscore character, as long as the subsequence characters are numerical digits and then the JPEG file extension. . Now that we confirmed the regular expression works for the example, let&#39;s use it to label the whole dataset. fastai comes with many classes to help with labeling. For labeling with regular expressions, we can use the RegexLabeller class. In this example we use the data block API we saw in &lt;&gt; (in fact, we nearly always use the data block API—it&#39;s so much more flexible than the simple factory methods we saw in &lt;&gt;):&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; pets = DataBlock(blocks = (ImageBlock, CategoryBlock), get_items=get_image_files, splitter=RandomSplitter(seed=42), get_y=using_attr(RegexLabeller(r&#39;(.+)_ d+.jpg$&#39;), &#39;name&#39;), item_tfms=Resize(460), batch_tfms=aug_transforms(size=224, min_scale=0.75)) dls = pets.dataloaders(path/&quot;images&quot;) . One important piece of this DataBlock call that we haven&#39;t seen before is in these two lines: . item_tfms=Resize(460), batch_tfms=aug_transforms(size=224, min_scale=0.75) . These lines implement a fastai data augmentation strategy which we call presizing. Presizing is a particular way to do image augmentation that is designed to minimize data destruction while maintaining good performance. . Presizing . We need our images to have the same dimensions, so that they can collate into tensors to be passed to the GPU. We also want to minimize the number of distinct augmentation computations we perform. The performance requirement suggests that we should, where possible, compose our augmentation transforms into fewer transforms (to reduce the number of computations and the number of lossy operations) and transform the images into uniform sizes (for more efficient processing on the GPU). . The challenge is that, if performed after resizing down to the augmented size, various common data augmentation transforms might introduce spurious empty zones, degrade data, or both. For instance, rotating an image by 45 degrees fills corner regions of the new bounds with emptiness, which will not teach the model anything. Many rotation and zooming operations will require interpolating to create pixels. These interpolated pixels are derived from the original image data but are still of lower quality. . To work around these challenges, presizing adopts two strategies that are shown in &lt;&gt;:&lt;/p&gt; Resize images to relatively &quot;large&quot; dimensions—that is, dimensions significantly larger than the target training dimensions. | Compose all of the common augmentation operations (including a resize to the final target size) into one, and perform the combined operation on the GPU only once at the end of processing, rather than performing the operations individually and interpolating multiple times. | The first step, the resize, creates images large enough that they have spare margin to allow further augmentation transforms on their inner regions without creating empty zones. This transformation works by resizing to a square, using a large crop size. On the training set, the crop area is chosen randomly, and the size of the crop is selected to cover the entire width or height of the image, whichever is smaller. . In the second step, the GPU is used for all data augmentation, and all of the potentially destructive operations are done together, with a single interpolation at the end. . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; This picture shows the two steps: . Crop full width or height: This is in item_tfms, so it&#39;s applied to each individual image before it is copied to the GPU. It&#39;s used to ensure all images are the same size. On the training set, the crop area is chosen randomly. On the validation set, the center square of the image is always chosen. | Random crop and augment: This is in batch_tfms, so it&#39;s applied to a batch all at once on the GPU, which means it&#39;s fast. On the validation set, only the resize to the final size needed for the model is done here. On the training set, the random crop and any other augmentations are done first. | To implement this process in fastai you use Resize as an item transform with a large size, and RandomResizedCrop as a batch transform with a smaller size. RandomResizedCrop will be added for you if you include the min_scale parameter in your aug_transforms function, as was done in the DataBlock call in the previous section. Alternatively, you can use pad or squish instead of crop (the default) for the initial Resize. . &lt;&gt; shows the difference between an image that has been zoomed, interpolated, rotated, and then interpolated again (which is the approach used by all other deep learning libraries), shown here on the right, and an image that has been zoomed and rotated as one operation and then interpolated just once on the left (the fastai approach), shown here on the left.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; You can see that the image on the right is less well defined and has reflection padding artifacts in the bottom-left corner; also, the grass iat the top left has disappeared entirely. We find that in practice using presizing significantly improves the accuracy of models, and often results in speedups too. . The fastai library also provides simple ways to check your data looks right before training a model, which is an extremely important step. We&#39;ll look at those next. . Checking and Debugging a DataBlock . We can never just assume that our code is working perfectly. Writing a DataBlock is just like writing a blueprint. You will get an error message if you have a syntax error somewhere in your code, but you have no guarantee that your template is going to work on your data source as you intend. So, before training a model you should always check your data. You can do this using the show_batch method: . dls.show_batch(nrows=2, ncols=5) . Take a look at each image, and check that each one seems to have the correct label for that breed of pet. Often, data scientists work with data with which they are not as familiar as domain experts may be: for instance, I actually don&#39;t know what a lot of these pet breeds are. Since I am not an expert on pet breeds, I would use Google images at this point to search for a few of these breeds, and make sure the images look similar to what I see in this output. . If you made a mistake while building your DataBlock, it is very likely you won&#39;t see it before this step. To debug this, we encourage you to use the summary method. It will attempt to create a batch from the source you give it, with a lot of details. Also, if it fails, you will see exactly at which point the error happens, and the library will try to give you some help. For instance, one common mistake is to forget to use a Resize transform, so you end up with pictures of different sizes and are not able to batch them. Here is what the summary would look like in that case (note that the exact text may have changed since the time of writing, but it will give you an idea): . pets1 = DataBlock(blocks = (ImageBlock, CategoryBlock), get_items=get_image_files, splitter=RandomSplitter(seed=42), get_y=using_attr(RegexLabeller(r&#39;(.+)_ d+.jpg$&#39;), &#39;name&#39;)) pets1.summary(path/&quot;images&quot;) . Setting-up type transforms pipelines Collecting items from /home/sgugger/.fastai/data/oxford-iiit-pet/images Found 7390 items 2 datasets of sizes 5912,1478 Setting up Pipeline: PILBase.create Setting up Pipeline: partial -&gt; Categorize Building one sample Pipeline: PILBase.create starting from /home/sgugger/.fastai/data/oxford-iiit-pet/images/american_bulldog_83.jpg applying PILBase.create gives PILImage mode=RGB size=375x500 Pipeline: partial -&gt; Categorize starting from /home/sgugger/.fastai/data/oxford-iiit-pet/images/american_bulldog_83.jpg applying partial gives american_bulldog applying Categorize gives TensorCategory(12) Final sample: (PILImage mode=RGB size=375x500, TensorCategory(12)) Setting up after_item: Pipeline: ToTensor Setting up before_batch: Pipeline: Setting up after_batch: Pipeline: IntToFloatTensor Building one batch Applying item_tfms to the first sample: Pipeline: ToTensor starting from (PILImage mode=RGB size=375x500, TensorCategory(12)) applying ToTensor gives (TensorImage of size 3x500x375, TensorCategory(12)) Adding the next 3 samples No before_batch transform to apply Collating items in a batch Error! It&#39;s not possible to collate your items in a batch Could not collate the 0-th members of your tuples because got the following shapes: torch.Size([3, 500, 375]),torch.Size([3, 375, 500]),torch.Size([3, 333, 500]), torch.Size([3, 375, 500]) . You can see exactly how we gathered the data and split it, how we went from a filename to a sample (the tuple (image, category)), then what item transforms were applied and how it failed to collate those samples in a batch (because of the different shapes). . Once you think your data looks right, we generally recommend the next step should be using it to train a simple model. We often see people put off the training of an actual model for far too long. As a result, they don&#39;t actually find out what their baseline results look like. Perhaps your problem doesn&#39;t need lots of fancy domain-specific engineering. Or perhaps the data doesn&#39;t seem to train the model at all. These are things that you want to know as soon as possible. For this initial test, we&#39;ll use the same simple model that we used in &lt;&gt;:&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fine_tune(2) . epoch train_loss valid_loss error_rate time . 0 | 1.536898 | 0.330109 | 0.108254 | 01:40 | . epoch train_loss valid_loss error_rate time . 0 | 0.518274 | 0.351195 | 0.104871 | 02:12 | . 1 | 0.322409 | 0.264386 | 0.086604 | 02:12 | . As we&#39;ve briefly discussed before, the table shown when we fit a model shows us the results after each epoch of training. Remember, an epoch is one complete pass through all of the images in the data. The columns shown are the average loss over the items of the training set, the loss on the validation set, and any metrics that we requested—in this case, the error rate. . Remember that loss is whatever function we&#39;ve decided to use to optimize the parameters of our model. But we haven&#39;t actually told fastai what loss function we want to use. So what is it doing? fastai will generally try to select an appropriate loss function based on what kind of data and model you are using. In this case we have image data and a categorical outcome, so fastai will default to using cross-entropy loss. . Cross-Entropy Loss . Cross-entropy loss is a loss function that is similar to the one we used in the previous chapter, but (as we&#39;ll see) has two benefits: . It works even when our dependent variable has more than two categories. | It results in faster and more reliable training. | . In order to understand how cross-entropy loss works for dependent variables with more than two categories, we first have to understand what the actual data and activations that are seen by the loss function look like. . Viewing Activations and Labels . Let&#39;s take a look at the activations of our model. To actually get a batch of real data from our DataLoaders, we can use the one_batch method: . x,y = dls.one_batch() . As you see, this returns the dependent and independent variables, as a mini-batch. Let&#39;s see what is actually contained in our dependent variable: . y . TensorCategory([21, 5, 13, 34, 21, 1, 2, 22, 26, 11, 29, 21, 19, 6, 21, 26, 26, 3, 11, 20, 23, 5, 2, 30, 28, 23, 33, 18, 34, 35, 26, 31, 16, 7, 25, 6, 18, 6, 13, 32, 25, 25, 11, 21, 21, 9, 8, 2, 5, 31, 27, 30, 31, 23, 15, 1, 11, 18, 24, 18, 7, 5, 25, 14], device=&#39;cuda:0&#39;) . Our batch size is 64, so we have 64 rows in this tensor. Each row is a single integer between 0 and 36, representing our 37 possible pet breeds. We can view the predictions (that is, the activations of the final layer of our neural network) using Learner.get_preds. This function either takes a dataset index (0 for train and 1 for valid) or an iterator of batches. Thus, we can pass it a simple list with our batch to get our predictions. It returns predictions and targets by default, but since we already have the targets, we can effectively ignore them by assigning to the special variable _: . preds,_ = learn.get_preds(dl=[(x,y)]) preds[0] . TensorImage([1.5562e-06, 6.0240e-08, 1.2071e-05, 1.7043e-07, 2.3885e-07, 3.3414e-06, 3.9245e-06, 2.2972e-06, 1.4141e-05, 2.7723e-06, 1.6189e-04, 5.6223e-07, 6.8836e-06, 3.0244e-06, 1.3965e-06, 2.1027e-06, 2.5647e-06, 2.1640e-07, 7.3500e-06, 3.6991e-04, 1.8530e-06, 9.8954e-01, 1.5230e-06, 7.4274e-07, 4.8789e-07, 5.4908e-04, 2.0195e-07, 2.2719e-05, 3.2026e-07, 2.1732e-05, 2.5376e-05, 1.0231e-05, 6.2508e-07, 5.1817e-06, 3.3510e-07, 9.2182e-03, 1.0359e-07]) . The actual predictions are 37 probabilities between 0 and 1, which add up to 1 in total: . len(preds[0]),preds[0].sum(),preds[0].max() . (37, TensorImage(1.), TensorImage(0.9895)) . To transform the activations of our model into predictions like this, we used something called the softmax activation function. . Softmax . In our classification model, we use the softmax activation function in the final layer to ensure that the activations are all between 0 and 1, and that they sum to 1. . Softmax is similar to the sigmoid function, which we saw earlier. As a reminder sigmoid looks like this: . plot_function(torch.sigmoid, min=-4,max=4) . We can apply this function to a single column of activations from a neural network, and get back a column of numbers between 0 and 1, so it&#39;s a very useful activation function for our final layer. . Now think about what happens if we want to have more categories in our target (such as our 37 pet breeds). That means we&#39;ll need more activations than just a single column: we need an activation per category. We can create, for instance, a neural net that predicts 3s and 7s that returns two activations, one for each class—this will be a good first step toward creating the more general approach. Let&#39;s just use some random numbers with a standard deviation of 2 (so we multiply randn by 2) for this example, assuming we have 6 images and 2 possible categories (where the first column represents 3s and the second is 7s): . acts = torch.randn((6,2))*2 # acts df = pd.DataFrame(acts) df.style.background_gradient(&#39;Greys&#39;) . 0 1 . 0 -2.568423 | -1.383355 | . 1 -1.071895 | 0.671044 | . 2 0.493873 | 0.064862 | . 3 0.811376 | 3.236237 | . 4 0.786310 | -0.429559 | . 5 2.530238 | -0.635614 | . We can&#39;t just take the sigmoid of this directly, since we don&#39;t get rows that add to 1 (i.e., we want the probability of being a 3 plus the probability of being a 7 to add up to 1): . data = acts.sigmoid() # display as table df = pd.DataFrame(data) df.style.background_gradient(&#39;Greys&#39;) . 0 1 . 0 0.071199 | 0.200471 | . 1 0.255043 | 0.661737 | . 2 0.621018 | 0.516210 | . 3 0.692403 | 0.962175 | . 4 0.687038 | 0.394232 | . 5 0.926235 | 0.346239 | . In &lt;&gt;, our neural net created a single activation per image, which we passed through the sigmoid function. That single activation represented the model&#39;s confidence that the input was a 3. Binary problems are a special case of classification problems, because the target can be treated as a single boolean value, as we did in mnist_loss. But binary problems can also be thought of in the context of the more general group of classifiers with any number of categories: in this case, we happen to have two categories. As we saw in the bear classifier, our neural net will return one activation per category.&lt;/p&gt; So in the binary case, what do those activations really indicate? A single pair of activations simply indicates the relative confidence of the input being a 3 versus being a 7. The overall values, whether they are both high, or both low, don&#39;t matter—all that matters is which is higher, and by how much. . We would expect that since this is just another way of representing the same problem, that we would be able to use sigmoid directly on the two-activation version of our neural net. And indeed we can! We can just take the difference between the neural net activations, because that reflects how much more sure we are of the input being a 3 than a 7, and then take the sigmoid of that: . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; (acts[:,0]-acts[:,1]).sigmoid() . tensor([0.2341, 0.1489, 0.6056, 0.0813, 0.7713, 0.9595]) . The second column (the probability of it being a 7) will then just be that value subtracted from 1. Now, we need a way to do all this that also works for more than two columns. It turns out that this function, called softmax, is exactly that: . def softmax(x): return exp(x) / exp(x).sum(dim=1, keepdim=True) . jargon:Exponential function (exp): Literally defined as e**x, where e is a special number approximately equal to 2.718. It is the inverse of the natural logarithm function. Note that exp is always positive, and it increases very rapidly! . Let&#39;s check that softmax returns the same values as sigmoid for the first column, and those values subtracted from 1 for the second column: . sm_acts = torch.softmax(acts, dim=1) sm_acts . tensor([[0.2341, 0.7659], [0.1489, 0.8511], [0.6056, 0.3944], [0.0813, 0.9187], [0.7713, 0.2287], [0.9595, 0.0405]]) . softmax is the multi-category equivalent of sigmoid—we have to use it any time we have more than two categories and the probabilities of the categories must add to 1, and we often use it even when there are just two categories, just to make things a bit more consistent. We could create other functions that have the properties that all activations are between 0 and 1, and sum to 1; however, no other function has the same relationship to the sigmoid function, which we&#39;ve seen is smooth and symmetric. Also, we&#39;ll see shortly that the softmax function works well hand-in-hand with the loss function we will look at in the next section. . If we have three output activations, such as in our bear classifier, calculating softmax for a single bear image would then look like something like &lt;&gt;.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; What does this function do in practice? Taking the exponential ensures all our numbers are positive, and then dividing by the sum ensures we are going to have a bunch of numbers that add up to 1. The exponential also has a nice property: if one of the numbers in our activations x is slightly bigger than the others, the exponential will amplify this (since it grows, well... exponentially), which means that in the softmax, that number will be closer to 1. . Intuitively, the softmax function really wants to pick one class among the others, so it&#39;s ideal for training a classifier when we know each picture has a definite label. (Note that it may be less ideal during inference, as you might want your model to sometimes tell you it doesn&#39;t recognize any of the classes that it has seen during training, and not pick a class because it has a slightly bigger activation score. In this case, it might be better to train a model using multiple binary output columns, each using a sigmoid activation.) . Softmax is the first part of the cross-entropy loss—the second part is log likelihood. . Log Likelihood . When we calculated the loss for our MNIST example in the last chapter we used: . def mnist_loss(inputs, targets): inputs = inputs.sigmoid() return torch.where(targets==1, 1-inputs, inputs).mean() . Just as we moved from sigmoid to softmax, we need to extend the loss function to work with more than just binary classification—it needs to be able to classify any number of categories (in this case, we have 37 categories). Our activations, after softmax, are between 0 and 1, and sum to 1 for each row in the batch of predictions. Our targets are integers between 0 and 36. . In the binary case, we used torch.where to select between inputs and 1-inputs. When we treat a binary classification as a general classification problem with two categories, it actually becomes even easier, because (as we saw in the previous section) we now have two columns, containing the equivalent of inputs and 1-inputs. So, all we need to do is select from the appropriate column. Let&#39;s try to implement this in PyTorch. For our synthetic 3s and 7s example, let&#39;s say these are our labels: . targ = tensor([0,1,0,1,1,0]) . and these are the softmax activations: . sm_acts # display as table df = pd.DataFrame(sm_acts) df.style.background_gradient(&#39;Greys&#39;) . 0 1 . 0 0.234142 | 0.765858 | . 1 0.148940 | 0.851060 | . 2 0.605638 | 0.394362 | . 3 0.081296 | 0.918703 | . 4 0.771336 | 0.228664 | . 5 0.959529 | 0.040471 | . Then for each item of targ we can use that to select the appropriate column of sm_acts using tensor indexing, like so: . idx = range(6) sm_acts[idx, targ] . tensor([0.2341, 0.8511, 0.6056, 0.9187, 0.2287, 0.9595]) . To see exactly what&#39;s happening here, let&#39;s put all the columns together in a table. Here, the first two columns are our activations, then we have the targets, the row index, and finally the result shown immediately above: . 3 7 targ idx loss . 0.234142 | 0.765858 | 0 | 0 | 0.234142 | . 0.148940 | 0.851060 | 1 | 1 | 0.851060 | . 0.605638 | 0.394362 | 0 | 2 | 0.605638 | . 0.081296 | 0.918703 | 1 | 3 | 0.918703 | . 0.771336 | 0.228664 | 1 | 4 | 0.228664 | . 0.959529 | 0.040471 | 0 | 5 | 0.959529 | . -sm_acts[idx, targ] . tensor([-0.2341, -0.8511, -0.6056, -0.9187, -0.2287, -0.9595]) . F.nll_loss(sm_acts, targ, reduction=&#39;none&#39;) . tensor([-0.2341, -0.8511, -0.6056, -0.9187, -0.2287, -0.9595]) . Despite its name, this PyTorch function does not take the log. We&#39;ll see why in the next section, but first, let&#39;s see why taking the logarithm can be useful. . Taking the Log . The function we saw in the previous section works quite well as a loss function, but we can make it a bit better. The problem is that we are using probabilities, and probabilities cannot be smaller than 0 or greater than 1. That means that our model will not care whether it predicts 0.99 or 0.999. Indeed, those numbers are so close together—but in another sense, 0.999 is 10 times more confident than 0.99. So, we want to transform our numbers between 0 and 1 to instead be between negative infinity and infinity. There is a mathematical function that does exactly this: the logarithm (available as torch.log). It is not defined for numbers less than 0, and looks like this: . plot_function(torch.log, min=0,max=4) . Does &quot;logarithm&quot; ring a bell? The logarithm function has this identity: . y = b**a a = log(y,b) . In this case, we&#39;re assuming that log(y,b) returns log y base b. However, PyTorch actually doesn&#39;t define log this way: log in Python uses the special number e (2.718...) as the base. . Perhaps a logarithm is something that you have not thought about for the last 20 years or so. But it&#39;s a mathematical idea that is going to be really critical for many things in deep learning, so now would be a great time to refresh your memory. The key thing to know about logarithms is this relationship: . log(a*b) = log(a)+log(b) . When we see it in that format, it looks a bit boring; but think about what this really means. It means that logarithms increase linearly when the underlying signal increases exponentially or multiplicatively. This is used, for instance, in the Richter scale of earthquake severity, and the dB scale of noise levels. It&#39;s also often used on financial charts, where we want to show compound growth rates more clearly. Computer scientists love using logarithms, because it means that multiplication, which can create really really large and really really small numbers, can be replaced by addition, which is much less likely to result in scales that are difficult for our computers to handle. . s:It&#39;s not just computer scientists that love logs! Until computers came along, engineers and scientists used a special ruler called a &quot;slide rule&quot; that did multiplication by adding logarithms. Logarithms are widely used in physics, for multiplying very big or very small numbers, and many other fields. . Taking the mean of the positive or negative log of our probabilities (depending on whether it&#39;s the correct or incorrect class) gives us the negative log likelihood loss. In PyTorch, nll_loss assumes that you already took the log of the softmax, so it doesn&#39;t actually do the logarithm for you. . . Warning: Confusing Name, Beware: The nll in nll_loss stands for &quot;negative log likelihood,&quot; but it doesn&#8217;t actually take the log at all! It assumes you have already taken the log. PyTorch has a function called log_softmax that combines log and softmax in a fast and accurate way. nll_loss is designed to be used after log_softmax. . When we first take the softmax, and then the log likelihood of that, that combination is called cross-entropy loss. In PyTorch, this is available as nn.CrossEntropyLoss (which, in practice, actually does log_softmax and then nll_loss): . loss_func = nn.CrossEntropyLoss() . As you see, this is a class. Instantiating it gives you an object which behaves like a function: . loss_func(acts, targ) . tensor(0.6194) . All PyTorch loss functions are provided in two forms, the class just shown above, and also a plain functional form, available in the F namespace: . F.cross_entropy(acts, targ) . tensor(0.6194) . Either one works fine and can be used in any situation. We&#39;ve noticed that most people tend to use the class version, and that&#39;s more often used in PyTorch&#39;s official docs and examples, so we&#39;ll tend to use that too. . By default PyTorch loss functions take the mean of the loss of all items. You can use reduction=&#39;none&#39; to disable that: . nn.CrossEntropyLoss(reduction=&#39;none&#39;)(acts, targ) . tensor([1.4518, 0.1613, 0.5015, 0.0848, 1.4755, 0.0413]) . s:An interesting feature about cross-entropy loss appears when we consider its gradient. The gradient of cross_entropy(a,b) is just softmax(a)-b. Since softmax(a) is just the final activation of the model, that means that the gradient is proportional to the difference between the prediction and the target. This is the same as mean squared error in regression (assuming there&#39;s no final activation function such as that added by y_range), since the gradient of (a-b)**2 is 2*(a-b). Because the gradient is linear, that means we won&#39;t see sudden jumps or exponential increases in gradients, which should lead to smoother training of models. . We have now seen all the pieces hidden behind our loss function. But while this puts a number on how well (or badly) our model is doing, it does nothing to help us know if it&#39;s actually any good. Let&#39;s now see some ways to interpret our model&#39;s predictions. . Model Interpretation . It&#39;s very hard to interpret loss functions directly, because they are designed to be things computers can differentiate and optimize, not things that people can understand. That&#39;s why we have metrics. These are not used in the optimization process, but just to help us poor humans understand what&#39;s going on. In this case, our accuracy is looking pretty good already! So where are we making mistakes? . We saw in &lt;&gt; that we can use a confusion matrix to see where our model is doing well, and where it&#39;s doing badly:&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(12,12), dpi=60) . Oh dear—in this case, a confusion matrix is very hard to read. We have 37 different breeds of pet, which means we have 37×37 entries in this giant matrix! Instead, we can use the most_confused method, which just shows us the cells of the confusion matrix with the most incorrect predictions (here, with at least 5 or more): . interp.most_confused(min_val=5) . [(&#39;american_pit_bull_terrier&#39;, &#39;staffordshire_bull_terrier&#39;, 7), (&#39;english_setter&#39;, &#39;english_cocker_spaniel&#39;, 5)] . Since we are not pet breed experts, it is hard for us to know whether these category errors reflect actual difficulties in recognizing breeds. So again, we turn to Google. A little bit of Googling tells us that the most common category errors shown here are actually breed differences that even expert breeders sometimes disagree about. So this gives us some comfort that we are on the right track. . We seem to have a good baseline. What can we do now to make it even better? . Improving Our Model . We will now look at a range of techniques to improve the training of our model and make it better. While doing so, we will explain a little bit more about transfer learning and how to fine-tune our pretrained model as best as possible, without breaking the pretrained weights. . The first thing we need to set when training a model is the learning rate. We saw in the previous chapter that it needs to be just right to train as efficiently as possible, so how do we pick a good one? fastai provides a tool for this. . The Learning Rate Finder . One of the most important things we can do when training a model is to make sure that we have the right learning rate. If our learning rate is too low, it can take many, many epochs to train our model. Not only does this waste time, but it also means that we may have problems with overfitting, because every time we do a complete pass through the data, we give our model a chance to memorize it. . So let&#39;s just make our learning rate really high, right? Sure, let&#39;s try that and see what happens: . learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fine_tune(1, base_lr=0.1) . epoch train_loss valid_loss error_rate time . 0 | 2.616048 | 3.006006 | 0.369418 | 01:40 | . epoch train_loss valid_loss error_rate time . 0 | 3.578125 | 2.175643 | 0.600812 | 02:12 | . That doesn&#39;t look good. Here&#39;s what happened. The optimizer stepped in the correct direction, but it stepped so far that it totally overshot the minimum loss. Repeating that multiple times makes it get further and further away, not closer and closer! . What do we do to find the perfect learning rate—not too high, and not too low? In 2015 the researcher Leslie Smith came up with a brilliant idea, called the learning rate finder. His idea was to start with a very, very small learning rate, something so small that we would never expect it to be too big to handle. We use that for one mini-batch, find what the losses are afterwards, and then increase the learning rate by some percentage (e.g., doubling it each time). Then we do another mini-batch, track the loss, and double the learning rate again. We keep doing this until the loss gets worse, instead of better. This is the point where we know we have gone too far. We then select a learning rate a bit lower than this point. Our advice is to pick either: . One order of magnitude less than where the minimum loss was achieved (i.e., the minimum divided by 10) | The last point where the loss was clearly decreasing | . The learning rate finder computes those points on the curve to help you. Both these rules usually give around the same value. In the first chapter, we didn&#39;t specify a learning rate, using the default value from the fastai library (which is 1e-3): . learn = cnn_learner(dls, resnet34, metrics=error_rate) lr_min,lr_steep = learn.lr_find() . print(f&quot;Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}&quot;) . Minimum/10: 1.00e-02, steepest point: 2.51e-03 . We can see on this plot that in the range 1e-6 to 1e-3, nothing really happens and the model doesn&#39;t train. Then the loss starts to decrease until it reaches a minimum, and then increases again. We don&#39;t want a learning rate greater than 1e-1 as it will give a training that diverges like the one before (you can try for yourself), but 1e-1 is already too high: at this stage we&#39;ve left the period where the loss was decreasing steadily. . In this learning rate plot it appears that a learning rate around 3e-3 would be appropriate, so let&#39;s choose that: . learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fine_tune(2, base_lr=3e-3) . epoch train_loss valid_loss error_rate time . 0 | 1.289578 | 0.326763 | 0.103518 | 01:40 | . epoch train_loss valid_loss error_rate time . 0 | 0.543674 | 0.403512 | 0.119756 | 02:12 | . 1 | 0.320895 | 0.267893 | 0.081191 | 02:12 | . . Note: Logarithmic Scale: The learning rate finder plot has a logarithmic scale, which is why the middle point between 1e-3 and 1e-2 is between 3e-3 and 4e-3. This is because we care mostly about the order of magnitude of the learning rate. . It&#39;s interesting that the learning rate finder was only discovered in 2015, while neural networks have been under development since the 1950s. Throughout that time finding a good learning rate has been, perhaps, the most important and challenging issue for practitioners. The soltuon does not require any advanced maths, giant computing resources, huge datasets, or anything else that would make it inaccessible to any curious researcher. Furthermore, Leslie Smith, was not part of some exclusive Silicon Valley lab, but was working as a naval researcher. All of this is to say: breakthrough work in deep learning absolutely does not require access to vast resources, elite teams, or advanced mathematical ideas. There is lots of work still to be done that requires just a bit of common sense, creativity, and tenacity. . Now that we have a good learning rate to train our model, let&#39;s look at how we can fine-tune the weights of a pretrained model. . Unfreezing and Transfer Learning . We discussed briefly in &lt;&gt; how transfer learning works. We saw that the basic idea is that a pretrained model, trained potentially on millions of data points (such as ImageNet), is fine-tuned for some other task. But what does this really mean?&lt;/p&gt; We now know that a convolutional neural network consists of many linear layers with a nonlinear activation function between each pair, followed by one or more final linear layers with an activation function such as softmax at the very end. The final linear layer uses a matrix with enough columns such that the output size is the same as the number of classes in our model (assuming that we are doing classification). . This final linear layer is unlikely to be of any use for us when we are fine-tuning in a transfer learning setting, because it is specifically designed to classify the categories in the original pretraining dataset. So when we do transfer learning we remove it, throw it away, and replace it with a new linear layer with the correct number of outputs for our desired task (in this case, there would be 37 activations). . This newly added linear layer will have entirely random weights. Therefore, our model prior to fine-tuning has entirely random outputs. But that does not mean that it is an entirely random model! All of the layers prior to the last one have been carefully trained to be good at image classification tasks in general. As we saw in the images from the Zeiler and Fergus paper in &lt;&gt; (see &lt;&gt; through &lt;&gt;), the first few layers encode very general concepts, such as finding gradients and edges, and later layers encode concepts that are still very useful for us, such as finding eyeballs and fur.&lt;/p&gt; We want to train a model in such a way that we allow it to remember all of these generally useful ideas from the pretrained model, use them to solve our particular task (classify pet breeds), and only adjust them as required for the specifics of our particular task. . Our challenge when fine-tuning is to replace the random weights in our added linear layers with weights that correctly achieve our desired task (classifying pet breeds) without breaking the carefully pretrained weights and the other layers. There is actually a very simple trick to allow this to happen: tell the optimizer to only update the weights in those randomly added final layers. Don&#39;t change the weights in the rest of the neural network at all. This is called freezing those pretrained layers. . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; When we create a model from a pretrained network fastai automatically freezes all of the pretrained layers for us. When we call the fine_tune method fastai does two things: . Trains the randomly added layers for one epoch, with all other layers frozen | Unfreezes all of the layers, and trains them all for the number of epochs requested | . Although this is a reasonable default approach, it is likely that for your particular dataset you may get better results by doing things slightly differently. The fine_tune method has a number of parameters you can use to change its behavior, but it might be easiest for you to just call the underlying methods directly if you want to get some custom behavior. Remember that you can see the source code for the method by using the following syntax: . learn.fine_tune?? . So let&#39;s try doing this manually ourselves. First of all we will train the randomly added layers for three epochs, using fit_one_cycle. As mentioned in &lt;&gt;, fit_one_cycle is the suggested way to train models without using fine_tune. We&#39;ll see why later in the book; in short, what fit_one_cycle does is to start training at a low learning rate, gradually increase it for the first section of training, and then gradually decrease it again for the last section of training.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; learn.fine_tune?? . learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fit_one_cycle(3, 3e-3) . epoch train_loss valid_loss error_rate time . 0 | 1.144477 | 0.367904 | 0.117050 | 01:40 | . 1 | 0.525094 | 0.264373 | 0.090663 | 01:40 | . 2 | 0.325775 | 0.246348 | 0.077808 | 01:41 | . Then we&#39;ll unfreeze the model: . learn.unfreeze() . and run lr_find again, because having more layers to train, and weights that have already been trained for three epochs, means our previously found learning rate isn&#39;t appropriate any more: . learn.lr_find() . SuggestedLRs(lr_min=1.4454397387453355e-06, lr_steep=3.981071586167673e-06) . Note that the graph is a little different from when we had random weights: we don&#39;t have that sharp descent that indicates the model is training. That&#39;s because our model has been trained already. Here we have a somewhat flat area before a sharp increase, and we should take a point well before that sharp increase—for instance, 1e-5. The point with the maximum gradient isn&#39;t what we look for here and should be ignored. . Let&#39;s train at a suitable learning rate: . learn.fit_one_cycle(6, lr_max=1e-5) . epoch train_loss valid_loss error_rate time . 0 | 0.256581 | 0.240293 | 0.079838 | 02:12 | . 1 | 0.247077 | 0.229675 | 0.071042 | 02:13 | . 2 | 0.218767 | 0.223359 | 0.074425 | 02:12 | . 3 | 0.193438 | 0.218866 | 0.071719 | 02:12 | . 4 | 0.192262 | 0.216983 | 0.073072 | 02:12 | . 5 | 0.186622 | 0.220845 | 0.071719 | 02:12 | . This has improved our model a bit, but there&#39;s more we can do. The deepest layers of our pretrained model might not need as high a learning rate as the last ones, so we should probably use different learning rates for those—this is known as using discriminative learning rates. . Discriminative Learning Rates . Even after we unfreeze, we still care a lot about the quality of those pretrained weights. We would not expect that the best learning rate for those pretrained parameters would be as high as for the randomly added parameters, even after we have tuned those randomly added parameters for a few epochs. Remember, the pretrained weights have been trained for hundreds of epochs, on millions of images. . In addition, do you remember the images we saw in &lt;&gt;, showing what each layer learns? The first layer learns very simple foundations, like edge and gradient detectors; these are likely to be just as useful for nearly any task. The later layers learn much more complex concepts, like &quot;eye&quot; and &quot;sunset,&quot; which might not be useful in your task at all (maybe you&#39;re classifying car models, for instance). So it makes sense to let the later layers fine-tune more quickly than earlier layers.&lt;/p&gt; Therefore, fastai&#39;s default approach is to use discriminative learning rates. This was originally developed in the ULMFiT approach to NLP transfer learning that we will introduce in &lt;&gt;. Like many good ideas in deep learning, it is extremely simple: use a lower learning rate for the early layers of the neural network, and a higher learning rate for the later layers (and especially the randomly added layers). The idea is based on insights developed by Jason Yosinski, who showed in 2014 that with transfer learning different layers of a neural network should train at different speeds, as seen in &lt;&gt;.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; fastai lets you pass a Python slice object anywhere that a learning rate is expected. The first value passed will be the learning rate in the earliest layer of the neural network, and the second value will be the learning rate in the final layer. The layers in between will have learning rates that are multiplicatively equidistant throughout that range. Let&#39;s use this approach to replicate the previous training, but this time we&#39;ll only set the lowest layer of our net to a learning rate of 1e-6; the other layers will scale up to 1e-4. Let&#39;s train for a while and see what happens: . learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fit_one_cycle(3, 3e-3) learn.unfreeze() learn.fit_one_cycle(12, lr_max=slice(1e-6,1e-4)) . epoch train_loss valid_loss error_rate time . 0 | 1.175592 | 0.329039 | 0.108254 | 01:40 | . 1 | 0.523019 | 0.277211 | 0.093369 | 01:40 | . 2 | 0.329954 | 0.250427 | 0.079838 | 01:41 | . epoch train_loss valid_loss error_rate time . 0 | 0.261914 | 0.247556 | 0.077131 | 02:12 | . 1 | 0.243407 | 0.240348 | 0.075101 | 02:13 | . 2 | 0.232381 | 0.232364 | 0.073072 | 02:13 | . 3 | 0.209051 | 0.224098 | 0.071042 | 02:12 | . 4 | 0.195854 | 0.223306 | 0.069012 | 02:12 | . 5 | 0.167482 | 0.225189 | 0.071719 | 02:12 | . 6 | 0.172200 | 0.218618 | 0.071042 | 02:13 | . 7 | 0.145802 | 0.222989 | 0.069689 | 02:12 | . 8 | 0.143970 | 0.218508 | 0.066982 | 02:12 | . 9 | 0.135541 | 0.216894 | 0.067659 | 02:12 | . 10 | 0.129646 | 0.215453 | 0.069012 | 02:12 | . 11 | 0.139278 | 0.215967 | 0.066982 | 02:13 | . Now the fine-tuning is working great! . fastai can show us a graph of the training and validation loss: . learn.recorder.plot_loss() . As you can see, the training loss keeps getting better and better. But notice that eventually the validation loss improvement slows, and sometimes even gets worse! This is the point at which the model is starting to over fit. In particular, the model is becoming overconfident of its predictions. But this does not mean that it is getting less accurate, necessarily. Take a look at the table of training results per epoch, and you will often see that the accuracy continues improving, even as the validation loss gets worse. In the end what matters is your accuracy, or more generally your chosen metrics, not the loss. The loss is just the function we&#39;ve given the computer to help us to optimize. . Another decision you have to make when training the model is for how long to train for. We&#39;ll consider that next. . Selecting the Number of Epochs . Often you will find that you are limited by time, rather than generalization and accuracy, when choosing how many epochs to train for. So your first approach to training should be to simply pick a number of epochs that will train in the amount of time that you are happy to wait for. Then look at the training and validation loss plots, as shown above, and in particular your metrics, and if you see that they are still getting better even in your final epochs, then you know that you have not trained for too long. . On the other hand, you may well see that the metrics you have chosen are really getting worse at the end of training. Remember, it&#39;s not just that we&#39;re looking for the validation loss to get worse, but the actual metrics. Your validation loss will first get worse during training because the model gets overconfident, and only later will get worse because it is incorrectly memorizing the data. We only care in practice about the latter issue. Remember, our loss function is just something that we use to allow our optimizer to have something it can differentiate and optimize; it&#39;s not actually the thing we care about in practice. . Before the days of 1cycle training it was very common to save the model at the end of each epoch, and then select whichever model had the best accuracy out of all of the models saved in each epoch. This is known as early stopping. However, this is very unlikely to give you the best answer, because those epochs in the middle occur before the learning rate has had a chance to reach the small values, where it can really find the best result. Therefore, if you find that you have overfit, what you should actually do is retrain your model from scratch, and this time select a total number of epochs based on where your previous best results were found. . If you have the time to train for more epochs, you may want to instead use that time to train more parameters—that is, use a deeper architecture. . Deeper Architectures . In general, a model with more parameters can model your data more accurately. (There are lots and lots of caveats to this generalization, and it depends on the specifics of the architectures you are using, but it is a reasonable rule of thumb for now.) For most of the architectures that we will be seeing in this book, you can create larger versions of them by simply adding more layers. However, since we want to use pretrained models, we need to make sure that we choose a number of layers that have already been pretrained for us. . This is why, in practice, architectures tend to come in a small number of variants. For instance, the ResNet architecture that we are using in this chapter comes in variants with 18, 34, 50, 101, and 152 layer, pretrained on ImageNet. A larger (more layers and parameters; sometimes described as the &quot;capacity&quot; of a model) version of a ResNet will always be able to give us a better training loss, but it can suffer more from overfitting, because it has more parameters to overfit with. . In general, a bigger model has the ability to better capture the real underlying relationships in your data, and also to capture and memorize the specific details of your individual images. . However, using a deeper model is going to require more GPU RAM, so you may need to lower the size of your batches to avoid an out-of-memory error. This happens when you try to fit too much inside your GPU and looks like: . Cuda runtime error: out of memory . You may have to restart your notebook when this happens. The way to solve it is to use a smaller batch size, which means passing smaller groups of images at any given time through your model. You can pass the batch size you want to the call creating your DataLoaders with bs=. . The other downside of deeper architectures is that they take quite a bit longer to train. One technique that can speed things up a lot is mixed-precision training. This refers to using less-precise numbers (half-precision floating point, also called fp16) where possible during training. As we are writing these words in early 2020, nearly all current NVIDIA GPUs support a special feature called tensor cores that can dramatically speed up neural network training, by 2-3x. They also require a lot less GPU memory. To enable this feature in fastai, just add to_fp16() after your Learner creation (you also need to import the module). . You can&#39;t really know ahead of time what the best architecture for your particular problem is—you need to try training some. So let&#39;s try a ResNet-50 now with mixed precision: . from fastai.callback.fp16 import * learn = cnn_learner(dls, resnet50, metrics=error_rate).to_fp16() learn.fine_tune(6, freeze_epochs=3) . Downloading: &#34;https://download.pytorch.org/models/resnet50-19c8e357.pth&#34; to /root/.cache/torch/hub/checkpoints/resnet50-19c8e357.pth . . epoch train_loss valid_loss error_rate time . 0 | 1.419752 | 0.291991 | 0.092693 | 02:22 | . 1 | 0.604999 | 0.286776 | 0.089986 | 02:22 | . 2 | 0.439003 | 0.268063 | 0.086604 | 02:22 | . epoch train_loss valid_loss error_rate time . 0 | 0.278134 | 0.247790 | 0.078484 | 03:13 | . 1 | 0.301751 | 0.489100 | 0.125169 | 03:13 | . 2 | 0.256536 | 0.257638 | 0.077808 | 03:12 | . 3 | 0.173610 | 0.243591 | 0.066306 | 03:13 | . 4 | 0.088985 | 0.203268 | 0.062246 | 03:12 | . 5 | 0.056218 | 0.195145 | 0.060893 | 03:13 | . You&#39;ll see here we&#39;ve gone back to using fine_tune, since it&#39;s so handy! We can pass freeze_epochs to tell fastai how many epochs to train for while frozen. It will automatically change learning rates appropriately for most datasets. . In this case, we&#39;re not seeing a clear win from the deeper model. This is useful to remember—bigger models aren&#39;t necessarily better models for your particular case! Make sure you try small models before you start scaling up. . Conclusion . In this chapter you learned some important practical tips, both for getting your image data ready for modeling (presizing, data block summary) and for fitting the model (learning rate finder, unfreezing, discriminative learning rates, setting the number of epochs, and using deeper architectures). Using these tools will help you to build more accurate image models, more quickly. . We also discussed cross-entropy loss. This part of the book is worth spending plenty of time on. You aren&#39;t likely to need to actually implement cross-entropy loss from scratch yourself in practice, but it&#39;s really important you understand the inputs to and output from that function, because it (or a variant of it, as we&#39;ll see in the next chapter) is used in nearly every classification model. So when you want to debug a model, or put a model in production, or improve the accuracy of a model, you&#39;re going to need to be able to look at its activations and loss, and understand what&#39;s going on, and why. You can&#39;t do that properly if you don&#39;t understand your loss function. . If cross-entropy loss hasn&#39;t &quot;clicked&quot; for you just yet, don&#39;t worry—you&#39;ll get there! First, go back to the last chapter and make sure you really understand mnist_loss. Then work gradually through the cells of the notebook for this chapter, where we step through each piece of cross-entropy loss. Make sure you understand what each calculation is doing, and why. Try creating some small tensors yourself and pass them into the functions, to see what they return. . Remember: the choices made in the implementation of cross-entropy loss are not the only possible choices that could have been made. Just like when we looked at regression we could choose between mean squared error and mean absolute difference (L1). If you have other ideas for possible functions that you think might work, feel free to give them a try in this chapter&#39;s notebook! (Fair warning though: you&#39;ll probably find that the model will be slower to train, and less accurate. That&#39;s because the gradient of cross-entropy loss is proportional to the difference between the activation and the target, so SGD always gets a nicely scaled step for the weights.) . Questionnaire . Why do we first resize to a large size on the CPU, and then to a smaller size on the GPU? | If you are not familiar with regular expressions, find a regular expression tutorial, and some problem sets, and complete them. Have a look on the book&#39;s website for suggestions. | What are the two ways in which data is most commonly provided, for most deep learning datasets? | Look up the documentation for L and try using a few of the new methods that it adds. | Look up the documentation for the Python pathlib module and try using a few methods of the Path class. | Give two examples of ways that image transformations can degrade the quality of the data. | What method does fastai provide to view the data in a DataLoaders? | What method does fastai provide to help you debug a DataBlock? | Should you hold off on training a model until you have thoroughly cleaned your data? | What are the two pieces that are combined into cross-entropy loss in PyTorch? | What are the two properties of activations that softmax ensures? Why is this important? | When might you want your activations to not have these two properties? | Calculate the exp and softmax columns of &lt;&gt; yourself (i.e., in a spreadsheet, with a calculator, or in a notebook).&lt;/li&gt; Why can&#39;t we use torch.where to create a loss function for datasets where our label can have more than two categories? | What is the value of log(-2)? Why? | What are two good rules of thumb for picking a learning rate from the learning rate finder? | What two steps does the fine_tune method do? | In Jupyter Notebook, how do you get the source code for a method or function? | What are discriminative learning rates? | How is a Python slice object interpreted when passed as a learning rate to fastai? | Why is early stopping a poor choice when using 1cycle training? | What is the difference between resnet50 and resnet101? | What does to_fp16 do? | &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Further Research . Find the paper by Leslie Smith that introduced the learning rate finder, and read it. | See if you can improve the accuracy of the classifier in this chapter. What&#39;s the best accuracy you can achieve? Look on the forums and the book&#39;s website to see what other students have achieved with this dataset, and how they did it. | &lt;/div&gt; | . . .",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/fastai/coursenotes/2021/01/08/fastai-05_pet_breeds.html",
            "relUrl": "/jupyter/ai/fastai/coursenotes/2021/01/08/fastai-05_pet_breeds.html",
            "date": " • Jan 8, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fast.ai - Under the Hood - Training a Digit Classifier",
            "content": ". Warning: This is just my notes from the excellent fast.ai MOOC which you can find here . Pixels: The Foundations of Computer Vision . Sidebar: Tenacity and Deep Learning . End sidebar . path = untar_data(URLs.MNIST_SAMPLE) . path.ls() . (#3) [Path(&#39;labels.csv&#39;),Path(&#39;valid&#39;),Path(&#39;train&#39;)] . (path/&#39;train&#39;).ls() . (#2) [Path(&#39;train/7&#39;),Path(&#39;train/3&#39;)] . threes = (path/&#39;train&#39;/&#39;3&#39;).ls().sorted() sevens = (path/&#39;train&#39;/&#39;7&#39;).ls().sorted() threes . (#6131) [Path(&#39;train/3/10.png&#39;),Path(&#39;train/3/10000.png&#39;),Path(&#39;train/3/10011.png&#39;),Path(&#39;train/3/10031.png&#39;),Path(&#39;train/3/10034.png&#39;),Path(&#39;train/3/10042.png&#39;),Path(&#39;train/3/10052.png&#39;),Path(&#39;train/3/1007.png&#39;),Path(&#39;train/3/10074.png&#39;),Path(&#39;train/3/10091.png&#39;)...] . im3_path = threes[1] im3 = Image.open(im3_path) im3 . array(im3)[4:10,4:10] . array([[ 0, 0, 0, 0, 0, 0], [ 0, 0, 0, 0, 0, 29], [ 0, 0, 0, 48, 166, 224], [ 0, 93, 244, 249, 253, 187], [ 0, 107, 253, 253, 230, 48], [ 0, 3, 20, 20, 15, 0]], dtype=uint8) . tensor(im3)[4:10,4:10] . tensor([[ 0, 0, 0, 0, 0, 0], [ 0, 0, 0, 0, 0, 29], [ 0, 0, 0, 48, 166, 224], [ 0, 93, 244, 249, 253, 187], [ 0, 107, 253, 253, 230, 48], [ 0, 3, 20, 20, 15, 0]], dtype=torch.uint8) . im3_t = tensor(im3) df = pd.DataFrame(im3_t[4:15,4:22]) df.style.set_properties(**{&#39;font-size&#39;:&#39;6pt&#39;}).background_gradient(&#39;Greys&#39;) . 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . 0 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | . 1 0 | 0 | 0 | 0 | 0 | 29 | 150 | 195 | 254 | 255 | 254 | 176 | 193 | 150 | 96 | 0 | 0 | 0 | . 2 0 | 0 | 0 | 48 | 166 | 224 | 253 | 253 | 234 | 196 | 253 | 253 | 253 | 253 | 233 | 0 | 0 | 0 | . 3 0 | 93 | 244 | 249 | 253 | 187 | 46 | 10 | 8 | 4 | 10 | 194 | 253 | 253 | 233 | 0 | 0 | 0 | . 4 0 | 107 | 253 | 253 | 230 | 48 | 0 | 0 | 0 | 0 | 0 | 192 | 253 | 253 | 156 | 0 | 0 | 0 | . 5 0 | 3 | 20 | 20 | 15 | 0 | 0 | 0 | 0 | 0 | 43 | 224 | 253 | 245 | 74 | 0 | 0 | 0 | . 6 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 249 | 253 | 245 | 126 | 0 | 0 | 0 | 0 | . 7 0 | 0 | 0 | 0 | 0 | 0 | 0 | 14 | 101 | 223 | 253 | 248 | 124 | 0 | 0 | 0 | 0 | 0 | . 8 0 | 0 | 0 | 0 | 0 | 11 | 166 | 239 | 253 | 253 | 253 | 187 | 30 | 0 | 0 | 0 | 0 | 0 | . 9 0 | 0 | 0 | 0 | 0 | 16 | 248 | 250 | 253 | 253 | 253 | 253 | 232 | 213 | 111 | 2 | 0 | 0 | . 10 0 | 0 | 0 | 0 | 0 | 0 | 0 | 43 | 98 | 98 | 208 | 253 | 253 | 253 | 253 | 187 | 22 | 0 | . First Try: Pixel Similarity . seven_tensors = [tensor(Image.open(o)) for o in sevens] three_tensors = [tensor(Image.open(o)) for o in threes] len(three_tensors),len(seven_tensors) . (6131, 6265) . show_image(three_tensors[1]); . stacked_sevens = torch.stack(seven_tensors).float()/255 stacked_threes = torch.stack(three_tensors).float()/255 stacked_threes.shape, stacked_sevens.shape . (torch.Size([6131, 28, 28]), torch.Size([6265, 28, 28])) . len(stacked_threes.shape) . 3 . stacked_threes.ndim . 3 . mean3 = stacked_threes.mean(0) show_image(mean3); . mean7 = stacked_sevens.mean(0) show_image(mean7); . a_3 = stacked_threes[1] show_image(a_3); . dist_3_abs = (a_3 - mean3).abs().mean() dist_3_sqr = ((a_3 - mean3)**2).mean().sqrt() dist_3_abs,dist_3_sqr . (tensor(0.1114), tensor(0.2021)) . dist_7_abs = (a_3 - mean7).abs().mean() dist_7_sqr = ((a_3 - mean7)**2).mean().sqrt() dist_7_abs,dist_7_sqr . (tensor(0.1586), tensor(0.3021)) . F.l1_loss(a_3.float(),mean7), F.mse_loss(a_3,mean7).sqrt() . (tensor(0.1586), tensor(0.3021)) . NumPy Arrays and PyTorch Tensors . data = [[1,2,3],[4,5,6]] arr = array (data) tns = tensor(data) . arr # numpy . tns # pytorch . tns[1] . tns[:,1] . tns[1,1:3] . tns+1 . tns.type() . tns*1.5 . Computing Metrics Using Broadcasting . valid_3_tens = torch.stack([tensor(Image.open(o)) for o in (path/&#39;valid&#39;/&#39;3&#39;).ls()]) valid_3_tens = valid_3_tens.float()/255 valid_7_tens = torch.stack([tensor(Image.open(o)) for o in (path/&#39;valid&#39;/&#39;7&#39;).ls()]) valid_7_tens = valid_7_tens.float()/255 valid_3_tens.shape,valid_7_tens.shape . (torch.Size([1010, 28, 28]), torch.Size([1028, 28, 28])) . def mnist_distance(a,b): return (a-b).abs().mean((-1,-2)) mnist_distance(a_3, mean3) . tensor(0.1114) . valid_3_dist = mnist_distance(valid_3_tens, mean3) valid_3_dist, valid_3_dist.shape . (tensor([0.1290, 0.1223, 0.1380, ..., 0.1337, 0.1132, 0.1097]), torch.Size([1010])) . tensor([1,2,3]) + tensor([1,1,1]) . tensor([2, 3, 4]) . (valid_3_tens-mean3).shape . torch.Size([1010, 28, 28]) . valid_3_tens.shape, mean3.shape . (torch.Size([1010, 28, 28]), torch.Size([28, 28])) . def is_3(x): return mnist_distance(x,mean3) &lt; mnist_distance(x,mean7) . is_3(a_3), is_3(a_3).float() . (tensor(True), tensor(1.)) . is_3(valid_3_tens) . tensor([True, True, True, ..., True, True, True]) . accuracy_3s = is_3(valid_3_tens).float() .mean() accuracy_7s = (1 - is_3(valid_7_tens).float()).mean() accuracy_3s,accuracy_7s,(accuracy_3s+accuracy_7s)/2 . (tensor(0.9168), tensor(0.9854), tensor(0.9511)) . is_3(stacked_threes).float().mean(), 1 - is_3(stacked_sevens).float().mean() . (tensor(0.8912), tensor(0.9962)) . Stochastic Gradient Descent (SGD) . gv(&#39;&#39;&#39; init-&gt;predict-&gt;loss-&gt;gradient-&gt;step-&gt;stop step-&gt;predict[label=repeat] &#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G init init predict predict init&#45;&gt;predict loss loss predict&#45;&gt;loss gradient gradient loss&#45;&gt;gradient step step gradient&#45;&gt;step step&#45;&gt;predict repeat stop stop step&#45;&gt;stop def f(x): return x**2 . plot_function(f, &#39;x&#39;, &#39;x**2&#39;) . plot_function(f, &#39;x&#39;, &#39;x**2&#39;) plt.scatter(-1.5, f(-1.5), color=&#39;red&#39;); . Calculating Gradients . x1 = -1. . xt = tensor(x1).requires_grad_() xt . tensor(-1., requires_grad=True) . yt = f(xt) yt.backward() yt . tensor(1., grad_fn=&lt;PowBackward0&gt;) . xt.grad . tensor(-2.) . def grad(x): return (x * xt.grad.item()) - yt.item() x = torch.linspace(-2,2) fig,ax = plt.subplots(figsize=(6,4)) ax.plot(x, f(x)) ax.plot(x, grad(x)) plt.scatter(x1, f(x1), color=&#39;red&#39;); plt.ylim(-.1, 4.1) . (-0.1, 4.1) . 3D gradients . xt = tensor([3.,4.,10.]).requires_grad_() xt . tensor([ 3., 4., 10.], requires_grad=True) . def f(x): return (x**2).sum() yt = f(xt) yt . tensor(125., grad_fn=&lt;SumBackward0&gt;) . yt.backward() xt.grad . tensor([ 6., 8., 20.]) . Stepping With a Learning Rate . An End-to-End SGD Example . time = torch.arange(0,20).float(); time . tensor([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19.]) . speed = torch.randn(20)*3 + 0.75*(time-9.5)**2 + 1 plt.scatter(time,speed); . $f(x, a, b, c) = ax^2 + bx + c$ . def f(t, params): a,b,c = params return a*(t**2) + (b*t) + c . $mse(predictions, targets) = sqrt{ frac{ sum(predictions - targets)^2}{n}} $ . def mse(preds, targets): return ((preds-targets)**2).mean().sqrt() . Step 1: Initialize the parameters . params = torch.randn(3).requires_grad_() . Step 2: Calculate the predictions . def show_preds(preds, ax=None): if ax is None: ax=plt.subplots()[1] ax.scatter(time, speed) ax.scatter(time, to_np(preds), color=&#39;red&#39;) ax.set_xlabel(&#39;time&#39;) ax.set_ylabel(&#39;predictions&#39;) ax.set_ylim(-300,100) . preds = f(time, params) . show_preds(preds) . Step 3: Calculate the loss . loss = mse(preds, speed) loss . tensor(141.6118, grad_fn=&lt;SqrtBackward&gt;) . Step 4: Calculate the gradients . loss.backward() params.grad . tensor([-164.9038, -10.5370, -0.7816]) . params.grad * 1e-5 . tensor([-1.6490e-03, -1.0537e-04, -7.8159e-06]) . params . tensor([-0.7244, 0.3629, 1.9200], requires_grad=True) . Step 5: Step the weights. . lr = 1e-3 params.data -= lr * params.grad.data params.grad = None . preds = f(time,params) mse(preds, speed) . tensor(114.4197, grad_fn=&lt;SqrtBackward&gt;) . show_preds(preds) . def apply_step(params, prn=True): preds = f(time, params) loss = mse(preds, speed) loss.backward() params.data -= lr * params.grad.data params.grad = None if prn: print(loss.item()) return preds . Step 6: Repeat the process . for i in range(10): apply_step(params) . 114.41970825195312 87.83831024169922 62.552642822265625 40.56702423095703 27.578344345092773 25.898353576660156 25.897171020507812 25.897003173828125 25.89684295654297 25.896682739257812 . _,axs = plt.subplots(1,5,figsize=(15,3)) for ax in axs: show_preds(apply_step(params, False), ax) plt.tight_layout() . _,axs = plt.subplots(1,5,figsize=(15,3)) for ax in axs: show_preds(apply_step(params, False), ax) plt.tight_layout() . Step 7: stop . Summarizing Gradient Descent . gv(&#39;&#39;&#39; init-&gt;predict-&gt;loss-&gt;gradient-&gt;step-&gt;stop step-&gt;predict[label=repeat] &#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G init init predict predict init&#45;&gt;predict loss loss predict&#45;&gt;loss gradient gradient loss&#45;&gt;gradient step step gradient&#45;&gt;step step&#45;&gt;predict repeat stop stop step&#45;&gt;stop The MNIST Loss Function . train_x = torch.cat([stacked_threes, stacked_sevens]).view(-1, 28*28) . train_y = tensor([1]*len(threes) + [0]*len(sevens)).unsqueeze(1) train_x.shape, train_y.shape . (torch.Size([12396, 784]), torch.Size([12396, 1])) . dset = list(zip(train_x,train_y)) x,y = dset[0] len(dset), x.shape, y.shape . (12396, torch.Size([784]), torch.Size([1])) . valid_x = torch.cat([valid_3_tens, valid_7_tens]).view(-1, 28*28) valid_y = tensor([1]*len(valid_3_tens) + [0]*len(valid_7_tens)).unsqueeze(1) valid_dset = list(zip(valid_x,valid_y)) . def init_params(size, std=1.0): return (torch.randn(size)*std).requires_grad_() . weights = init_params((28*28,1)) . bias = init_params(1) . (train_x[0]*weights.T).sum() + bias . tensor([3.7602], grad_fn=&lt;AddBackward0&gt;) . def linear1(xb): return xb@weights + bias preds = linear1(train_x) preds . tensor([[ 3.7602], [10.0223], [15.1395], ..., [ 4.7646], [ 1.8502], [ 3.3399]], grad_fn=&lt;AddBackward0&gt;) . corrects = (preds&gt;0.0).float() == train_y corrects . tensor([[ True], [ True], [ True], ..., [False], [False], [False]]) . corrects.float().mean().item() . 0.4820910096168518 . weights[0] *= 1.0001 . weights.shape . torch.Size([784, 1]) . preds = linear1(train_x) ((preds&gt;0.0).float() == train_y).float().mean().item() . 0.4820910096168518 . trgts = tensor([1,0,1]) prds = tensor([0.9, 0.4, 0.2]) . def mnist_loss(predictions, targets): return torch.where(targets==1, 1-predictions, predictions).mean() . torch.where(trgts==1, 1-prds, prds) . tensor([0.1000, 0.4000, 0.8000]) . mnist_loss(prds,trgts) . tensor(0.4333) . mnist_loss(tensor([0.9, 0.4, 0.8]),trgts) . tensor(0.2333) . Sigmoid . def sigmoid(x): return 1/(1+torch.exp(-x)) . plot_function(torch.sigmoid, title=&#39;Sigmoid&#39;, min=-6, max=6) . def mnist_loss(predictions, targets): predictions = predictions.sigmoid() return torch.where(targets==1, 1-predictions, predictions).mean() . mnist_loss(tensor([1., 0., 1.]), tensor([1.,0.,1.])) . tensor(0.3460) . SGD and Mini-Batches . coll = range(15) dl = DataLoader(coll, batch_size=5, shuffle=True) list(dl) . [tensor([ 3, 12, 8, 10, 2]), tensor([ 9, 4, 7, 14, 5]), tensor([ 1, 13, 0, 6, 11])] . ds = L(enumerate(string.ascii_lowercase)) ds . (#26) [(0, &#39;a&#39;),(1, &#39;b&#39;),(2, &#39;c&#39;),(3, &#39;d&#39;),(4, &#39;e&#39;),(5, &#39;f&#39;),(6, &#39;g&#39;),(7, &#39;h&#39;),(8, &#39;i&#39;),(9, &#39;j&#39;)...] . dl = DataLoader(ds, batch_size=6, shuffle=True) list(dl) . [(tensor([17, 18, 10, 22, 8, 14]), (&#39;r&#39;, &#39;s&#39;, &#39;k&#39;, &#39;w&#39;, &#39;i&#39;, &#39;o&#39;)), (tensor([20, 15, 9, 13, 21, 12]), (&#39;u&#39;, &#39;p&#39;, &#39;j&#39;, &#39;n&#39;, &#39;v&#39;, &#39;m&#39;)), (tensor([ 7, 25, 6, 5, 11, 23]), (&#39;h&#39;, &#39;z&#39;, &#39;g&#39;, &#39;f&#39;, &#39;l&#39;, &#39;x&#39;)), (tensor([ 1, 3, 0, 24, 19, 16]), (&#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;y&#39;, &#39;t&#39;, &#39;q&#39;)), (tensor([2, 4]), (&#39;c&#39;, &#39;e&#39;))] . Putting It All Together . weights = init_params((28*28,1)) bias = init_params(1) . dl = DataLoader(dset, batch_size=256) xb,yb = first(dl) xb.shape,yb.shape . (torch.Size([256, 784]), torch.Size([256, 1])) . valid_dl = DataLoader(valid_dset, batch_size=256) . batch = train_x[:4] batch.shape . torch.Size([4, 784]) . preds = linear1(batch) preds . tensor([[ 9.7460], [14.8540], [ 6.6535], [11.8257]], grad_fn=&lt;AddBackward0&gt;) . loss = mnist_loss(preds, train_y[:4]) loss . tensor(0.0003, grad_fn=&lt;MeanBackward0&gt;) . loss.backward() weights.grad.shape,weights.grad.mean(),bias.grad . (torch.Size([784, 1]), tensor(-4.8543e-05), tensor([-0.0003])) . def calc_grad(xb, yb, model): preds = model(xb) loss = mnist_loss(preds, yb) loss.backward() . calc_grad(batch, train_y[:4], linear1) weights.grad.mean(),bias.grad . (tensor(-9.7085e-05), tensor([-0.0007])) . calc_grad(batch, train_y[:4], linear1) weights.grad.mean(),bias.grad . (tensor(-0.0001), tensor([-0.0010])) . weights.grad.zero_() bias.grad.zero_(); . def train_epoch(model, lr, params): for xb,yb in dl: calc_grad(xb, yb, model) for p in params: p.data -= p.grad*lr p.grad.zero_() . (preds&gt;0.0).float() == train_y[:4] . tensor([[True], [True], [True], [True]]) . def batch_accuracy(xb, yb): preds = xb.sigmoid() correct = (preds&gt;0.5) == yb return correct.float().mean() . batch_accuracy(linear1(batch), train_y[:4]) . tensor(1.) . def validate_epoch(model): accs = [batch_accuracy(model(xb), yb) for xb,yb in valid_dl] return round(torch.stack(accs).mean().item(), 4) . validate_epoch(linear1) . 0.6554 . lr = 1. params = weights,bias train_epoch(linear1, lr, params) validate_epoch(linear1) . 0.7372 . for i in range(20): train_epoch(linear1, lr, params) print(validate_epoch(linear1), end=&#39; &#39;) . 0.8886 0.932 0.9457 0.954 0.9584 0.9598 0.9623 0.9643 0.9648 0.9662 0.9672 0.9677 0.9682 0.9696 0.9701 0.9701 0.9706 0.9716 0.9721 0.9721 . Creating an Optimizer . linear_model = nn.Linear(28*28,1) . w,b = linear_model.parameters() w.shape,b.shape . (torch.Size([1, 784]), torch.Size([1])) . class BasicOptim: def __init__(self,params,lr): self.params,self.lr = list(params),lr def step(self, *args, **kwargs): for p in self.params: p.data -= p.grad.data * self.lr def zero_grad(self, *args, **kwargs): for p in self.params: p.grad = None . opt = BasicOptim(linear_model.parameters(), lr) . def train_epoch(model): for xb,yb in dl: calc_grad(xb, yb, model) opt.step() opt.zero_grad() . validate_epoch(linear_model) . 0.4562 . def train_model(model, epochs): for i in range(epochs): train_epoch(model) print(validate_epoch(model), end=&#39; &#39;) . train_model(linear_model, 20) . 0.4932 0.7354 0.8564 0.9179 0.9345 0.9487 0.957 0.9638 0.9658 0.9672 0.9692 0.9716 0.9746 0.9746 0.976 0.9765 0.9775 0.9775 0.978 0.9785 . linear_model = nn.Linear(28*28,1) opt = SGD(linear_model.parameters(), lr) train_model(linear_model, 20) . 0.4932 0.8091 0.8481 0.916 0.9336 0.9487 0.956 0.9638 0.9663 0.9682 0.9692 0.9721 0.9736 0.9751 0.976 0.977 0.9775 0.978 0.978 0.9785 . dls = DataLoaders(dl, valid_dl) . learn = Learner(dls, nn.Linear(28*28,1), opt_func=SGD, loss_func=mnist_loss, metrics=batch_accuracy) . learn.fit(20, lr=lr) . epoch train_loss valid_loss batch_accuracy time . 0 | 0.637234 | 0.503652 | 0.495584 | 00:00 | . 1 | 0.622813 | 0.099536 | 0.934740 | 00:00 | . 2 | 0.224453 | 0.229068 | 0.785574 | 00:00 | . 3 | 0.096522 | 0.119550 | 0.899411 | 00:00 | . 4 | 0.049351 | 0.083758 | 0.929343 | 00:00 | . 5 | 0.031013 | 0.065843 | 0.941119 | 00:00 | . 6 | 0.023518 | 0.055016 | 0.954367 | 00:00 | . 7 | 0.020242 | 0.047905 | 0.961236 | 00:00 | . 8 | 0.018628 | 0.042962 | 0.964671 | 00:00 | . 9 | 0.017691 | 0.039352 | 0.967125 | 00:00 | . 10 | 0.017050 | 0.036603 | 0.968597 | 00:00 | . 11 | 0.016553 | 0.034435 | 0.971541 | 00:00 | . 12 | 0.016141 | 0.032674 | 0.972522 | 00:00 | . 13 | 0.015789 | 0.031212 | 0.973994 | 00:00 | . 14 | 0.015485 | 0.029979 | 0.975957 | 00:00 | . 15 | 0.015220 | 0.028927 | 0.976448 | 00:00 | . 16 | 0.014989 | 0.028021 | 0.977429 | 00:00 | . 17 | 0.014785 | 0.027235 | 0.977429 | 00:00 | . 18 | 0.014602 | 0.026546 | 0.977920 | 00:00 | . 19 | 0.014437 | 0.025939 | 0.978410 | 00:00 | . Adding a Nonlinearity . def simple_net(xb): res = xb@w1 + b1 res = res.max(tensor(0.0)) res = res@w2 + b2 return res . w1 = init_params((28*28,30)) b1 = init_params(30) w2 = init_params((30,1)) b2 = init_params(1) . plot_function(F.relu) . simple_net = nn.Sequential( nn.Linear(28*28,30), nn.ReLU(), nn.Linear(30,1) ) . learn = Learner(dls, simple_net, opt_func=SGD, loss_func=mnist_loss, metrics=batch_accuracy) . learn.fit(40, 0.1) . epoch train_loss valid_loss batch_accuracy time . 0 | 0.316475 | 0.418682 | 0.504416 | 00:00 | . 1 | 0.149121 | 0.231948 | 0.799313 | 00:00 | . 2 | 0.082135 | 0.115575 | 0.915604 | 00:00 | . 3 | 0.053724 | 0.077822 | 0.940137 | 00:00 | . 4 | 0.040625 | 0.060725 | 0.955839 | 00:00 | . 5 | 0.033974 | 0.051135 | 0.964181 | 00:00 | . 6 | 0.030173 | 0.045101 | 0.965653 | 00:00 | . 7 | 0.027711 | 0.040987 | 0.965653 | 00:00 | . 8 | 0.025942 | 0.037986 | 0.968106 | 00:00 | . 9 | 0.024574 | 0.035688 | 0.971050 | 00:00 | . 10 | 0.023464 | 0.033859 | 0.972522 | 00:00 | . 11 | 0.022537 | 0.032356 | 0.973013 | 00:00 | . 12 | 0.021745 | 0.031094 | 0.973503 | 00:00 | . 13 | 0.021058 | 0.030013 | 0.974975 | 00:00 | . 14 | 0.020455 | 0.029072 | 0.975466 | 00:00 | . 15 | 0.019920 | 0.028244 | 0.976938 | 00:00 | . 16 | 0.019441 | 0.027508 | 0.977920 | 00:00 | . 17 | 0.019008 | 0.026849 | 0.977920 | 00:00 | . 18 | 0.018614 | 0.026254 | 0.977920 | 00:00 | . 19 | 0.018253 | 0.025716 | 0.978901 | 00:00 | . 20 | 0.017922 | 0.025225 | 0.978901 | 00:00 | . 21 | 0.017615 | 0.024774 | 0.979392 | 00:00 | . 22 | 0.017330 | 0.024360 | 0.979882 | 00:00 | . 23 | 0.017064 | 0.023978 | 0.980373 | 00:00 | . 24 | 0.016814 | 0.023624 | 0.980864 | 00:00 | . 25 | 0.016579 | 0.023295 | 0.980864 | 00:00 | . 26 | 0.016357 | 0.022990 | 0.981845 | 00:00 | . 27 | 0.016148 | 0.022705 | 0.981845 | 00:00 | . 28 | 0.015949 | 0.022439 | 0.982336 | 00:00 | . 29 | 0.015761 | 0.022191 | 0.982336 | 00:00 | . 30 | 0.015581 | 0.021958 | 0.982336 | 00:00 | . 31 | 0.015410 | 0.021740 | 0.983317 | 00:00 | . 32 | 0.015247 | 0.021534 | 0.983808 | 00:00 | . 33 | 0.015091 | 0.021340 | 0.983808 | 00:00 | . 34 | 0.014941 | 0.021157 | 0.983808 | 00:00 | . 35 | 0.014797 | 0.020985 | 0.983317 | 00:00 | . 36 | 0.014659 | 0.020822 | 0.983317 | 00:00 | . 37 | 0.014525 | 0.020667 | 0.983317 | 00:00 | . 38 | 0.014396 | 0.020520 | 0.983317 | 00:00 | . 39 | 0.014272 | 0.020378 | 0.983317 | 00:00 | . plt.plot(L(learn.recorder.values).itemgot(2)); . learn.recorder.values[-1][2] . 0.983316957950592 . Going Deeper . dls = ImageDataLoaders.from_folder(path) learn = cnn_learner(dls, resnet18, pretrained=False, loss_func=F.cross_entropy, metrics=accuracy) learn.fit_one_cycle(1, 0.1) . epoch train_loss valid_loss accuracy time . 0 | 0.111226 | 0.045557 | 0.993621 | 00:19 | . Jargon Recap . Questionnaire . How is a grayscale image represented on a computer? How about a color image? | How are the files and folders in the MNIST_SAMPLE dataset structured? Why? | Explain how the &quot;pixel similarity&quot; approach to classifying digits works. | What is a list comprehension? Create one now that selects odd numbers from a list and doubles them. | What is a &quot;rank-3 tensor&quot;? | What is the difference between tensor rank and shape? How do you get the rank from the shape? | What are RMSE and L1 norm? | How can you apply a calculation on thousands of numbers at once, many thousands of times faster than a Python loop? | Create a 3×3 tensor or array containing the numbers from 1 to 9. Double it. Select the bottom-right four numbers. | What is broadcasting? | Are metrics generally calculated using the training set, or the validation set? Why? | What is SGD? | Why does SGD use mini-batches? | What are the seven steps in SGD for machine learning? | How do we initialize the weights in a model? | What is &quot;loss&quot;? | Why can&#39;t we always use a high learning rate? | What is a &quot;gradient&quot;? | Do you need to know how to calculate gradients yourself? | Why can&#39;t we use accuracy as a loss function? | Draw the sigmoid function. What is special about its shape? | What is the difference between a loss function and a metric? | What is the function to calculate new weights using a learning rate? | What does the DataLoader class do? | Write pseudocode showing the basic steps taken in each epoch for SGD. | Create a function that, if passed two arguments [1,2,3,4] and &#39;abcd&#39;, returns [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;)]. What is special about that output data structure? | What does view do in PyTorch? | What are the &quot;bias&quot; parameters in a neural network? Why do we need them? | What does the @ operator do in Python? | What does the backward method do? | Why do we have to zero the gradients? | What information do we have to pass to Learner? | Show Python or pseudocode for the basic steps of a training loop. | What is &quot;ReLU&quot;? Draw a plot of it for values from -2 to +2. | What is an &quot;activation function&quot;? | What&#39;s the difference between F.relu and nn.ReLU? | The universal approximation theorem shows that any function can be approximated as closely as needed using just one nonlinearity. So why do we normally use more? | Further Research . Create your own implementation of Learner from scratch, based on the training loop shown in this chapter. | Complete all the steps in this chapter using the full MNIST datasets (that is, for all digits, not just 3s and 7s). This is a significant project and will take you quite a bit of time to complete! You&#39;ll need to do some of your own research to figure out how to overcome some obstacles you&#39;ll meet on the way. |",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/fastai/coursenotes/2021/01/07/fastai-04_mnist_basics.html",
            "relUrl": "/jupyter/ai/fastai/coursenotes/2021/01/07/fastai-04_mnist_basics.html",
            "date": " • Jan 7, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Fast.ai - From Model to Production",
            "content": ". Warning: This is just my notes from the excellent fast.ai MOOC which you can find here . The Practice of Deep Learning . Starting Your Project . The State of Deep Learning . Computer vision . Text (natural language processing) . Combining text and images . Tabular data . Recommendation systems . Other data types . The Drivetrain Approach . Gathering Data . clean . To download images with Bing Image Search, sign up at Microsoft Azure for a free account. You will be given a key, which you can copy and enter in a cell as follows (replacing &#39;XXX&#39; with your key and executing it): . search_images_ddg . &lt;function fastbook.search_images_ddg(term, max_images=200)&gt; . search_images_bing . &lt;function fastbook.search_images_bing(key, term, min_sz=128, max_images=150)&gt; . results = search_images_bing(key, &#39;grizzly bear&#39;) ims = results.attrgot(&#39;contentUrl&#39;) len(ims) . 150 . ims . (#150) [&#39;https://images.gearjunkie.com/uploads/2015/07/Grizzly-Bear.jpg&#39;,&#39;http://someinterestingfacts.net/wp-content/uploads/2016/07/Canadian-Grizzly-Bear.jpg&#39;,&#39;http://www.pbs.org/wnet/nature/files/2018/07/Bear133.jpg&#39;,&#39;http://wildlifearticles.co.uk/wp-content/uploads/2015/10/grizzly-bear3.jpg&#39;,&#39;https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/GrizzlyBearJeanBeaufort.jpg/1200px-GrizzlyBearJeanBeaufort.jpg&#39;,&#39;https://gohunt-assets-us-west-2.s3.amazonaws.com/wyoming-grizzly-bear-og_0.jpg&#39;,&#39;https://upload.wikimedia.org/wikipedia/commons/e/e2/Grizzlybear55.jpg&#39;,&#39;https://i0.wp.com/www.commonsenseevaluation.com/wp-content/uploads/2013/08/Bear.jpg&#39;,&#39;https://www.tsln.com/wp-content/uploads/2018/10/bears-tsln-101318-3-1240x826.jpg&#39;,&#39;https://d3d0lqu00lnqvz.cloudfront.net/media/media/897b2e5d-6d4c-40fa-bbe8-6829455747e2.jpg&#39;...] . dest = &#39;../images/grizzly.jpg&#39; download_url(ims[0], dest) . im = Image.open(dest) im.to_thumb(128,128) . bear_types = &#39;grizzly&#39;,&#39;black&#39;,&#39;teddy&#39; path = Path(&#39;bears&#39;) . if not path.exists(): path.mkdir() for o in bear_types: dest = (path/o) dest.mkdir(exist_ok=True) results = search_images_bing(key, f&#39;{o} bear&#39;) download_images(dest, urls=results.attrgot(&#39;contentUrl&#39;)) . fns = get_image_files(path) fns . (#436) [Path(&#39;bears/grizzly/00000007.jpg&#39;),Path(&#39;bears/grizzly/00000002.jpg&#39;),Path(&#39;bears/grizzly/00000001.jpg&#39;),Path(&#39;bears/grizzly/00000004.jpg&#39;),Path(&#39;bears/grizzly/00000006.jpg&#39;),Path(&#39;bears/grizzly/00000008.jpg&#39;),Path(&#39;bears/grizzly/00000009.jpg&#39;),Path(&#39;bears/grizzly/00000003.jpg&#39;),Path(&#39;bears/grizzly/00000014.jpg&#39;),Path(&#39;bears/grizzly/00000012.jpg&#39;)...] . failed = verify_images(fns) failed . (#0) [] . failed.map(Path.unlink); . Sidebar: Getting Help in Jupyter Notebooks . End sidebar . From Data to DataLoaders . bears = DataBlock( blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, splitter=RandomSplitter(valid_pct=0.2, seed=42), get_y=parent_label, item_tfms=Resize(128)) . doc(parent_label) . dls = bears.dataloaders(path) . dls.valid.show_batch(max_n=12, nrows=2) . bears = bears.new(item_tfms=Resize(128, ResizeMethod.Squish)) dls = bears.dataloaders(path) dls.valid.show_batch(max_n=4, nrows=1) . bears = bears.new(item_tfms=Resize(128, ResizeMethod.Pad, pad_mode=&#39;zeros&#39;)) dls = bears.dataloaders(path) dls.valid.show_batch(max_n=4, nrows=1) . bears = bears.new(item_tfms=RandomResizedCrop(128, min_scale=0.3)) dls = bears.dataloaders(path) dls.train.show_batch(max_n=4, nrows=1, unique=True) . Data Augmentation . bears = bears.new(item_tfms=Resize(128), batch_tfms=aug_transforms(mult=2)) dls = bears.dataloaders(path) dls.train.show_batch(max_n=8, nrows=2, unique=True) . Training Your Model, and Using It to Clean Your Data . bears = bears.new( item_tfms=RandomResizedCrop(224, min_scale=0.5), batch_tfms=aug_transforms()) dls = bears.dataloaders(path) . learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fine_tune(4) . epoch train_loss valid_loss error_rate time . 0 | 1.248772 | 0.102475 | 0.034483 | 00:10 | . epoch train_loss valid_loss error_rate time . 0 | 0.093664 | 0.066300 | 0.022989 | 00:11 | . 1 | 0.067296 | 0.090083 | 0.022989 | 00:10 | . 2 | 0.047179 | 0.104809 | 0.022989 | 00:10 | . 3 | 0.037067 | 0.096211 | 0.034483 | 00:12 | . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix() . interp.plot_top_losses(5, nrows=1) . cleaner = ImageClassifierCleaner(learn) cleaner . Turning Your Model into an Online Application . Using the Model for Inference . learn.export() . path = Path() path.ls(file_exts=&#39;.pkl&#39;) . (#1) [Path(&#39;export.pkl&#39;)] . learn_inf = load_learner(path/&#39;export.pkl&#39;) . learn_inf.predict(&#39;../images/grizzly.jpg&#39;) . (&#39;grizzly&#39;, TensorImage(1), TensorImage([3.2993e-07, 1.0000e+00, 1.7181e-07])) . learn_inf.dls.vocab . [&#39;black&#39;, &#39;grizzly&#39;, &#39;teddy&#39;] . Creating a Notebook App from the Model . btn_upload = widgets.FileUpload() btn_upload . img = PILImage.create(btn_upload.data[-1]) . out_pl = widgets.Output() out_pl.clear_output() with out_pl: display(img.to_thumb(128,128)) out_pl . pred,pred_idx,probs = learn_inf.predict(img) . lbl_pred = widgets.Label() lbl_pred.value = f&#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}&#39; lbl_pred . btn_run = widgets.Button(description=&#39;Classify&#39;) btn_run . def on_click_classify(change): img = PILImage.create(btn_upload.data[-1]) out_pl.clear_output() with out_pl: display(img.to_thumb(128,128)) pred,pred_idx,probs = learn_inf.predict(img) lbl_pred.value = f&#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}&#39; btn_run.on_click(on_click_classify) . VBox([widgets.Label(&#39;Select your bear!&#39;), btn_upload, btn_run, out_pl, lbl_pred]) . Turning Your Notebook into a Real App . Deploying your app . How to Avoid Disaster . Unforeseen Consequences and Feedback Loops . Get Writing! . Questionnaire . Provide an example of where the bear classification model might work poorly in production, due to structural or style differences in the training data. | Where do text models currently have a major deficiency? | What are possible negative societal implications of text generation models? | In situations where a model might make mistakes, and those mistakes could be harmful, what is a good alternative to automating a process? | What kind of tabular data is deep learning particularly good at? | What&#39;s a key downside of directly using a deep learning model for recommendation systems? | What are the steps of the Drivetrain Approach? | How do the steps of the Drivetrain Approach map to a recommendation system? | Create an image recognition model using data you curate, and deploy it on the web. | What is DataLoaders? | What four things do we need to tell fastai to create DataLoaders? | What does the splitter parameter to DataBlock do? | How do we ensure a random split always gives the same validation set? | What letters are often used to signify the independent and dependent variables? | What&#39;s the difference between the crop, pad, and squish resize approaches? When might you choose one over the others? | What is data augmentation? Why is it needed? | What is the difference between item_tfms and batch_tfms? | What is a confusion matrix? | What does export save? | What is it called when we use a model for getting predictions, instead of training? | What are IPython widgets? | When might you want to use CPU for deployment? When might GPU be better? | What are the downsides of deploying your app to a server, instead of to a client (or edge) device such as a phone or PC? | What are three examples of problems that could occur when rolling out a bear warning system in practice? | What is &quot;out-of-domain data&quot;? | What is &quot;domain shift&quot;? | What are the three steps in the deployment process? | Further Research . Consider how the Drivetrain Approach maps to a project or problem you&#39;re interested in. | When might it be best to avoid certain types of data augmentation? | For a project you&#39;re interested in applying deep learning to, consider the thought experiment &quot;What would happen if it went really, really well?&quot; | Start a blog, and write your first blog post. For instance, write about what you think deep learning might be useful for in a domain you&#39;re interested in. |",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/fastai/coursenotes/2021/01/06/fastai-02_production.html",
            "relUrl": "/jupyter/ai/fastai/coursenotes/2021/01/06/fastai-02_production.html",
            "date": " • Jan 6, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Fast.ai - Your Deep Learning Journey",
            "content": ". Warning: This is just my notes from the excellent fast.ai MOOC which you can find here . Deep Learning Is for Everyone . Neural Networks: A Brief History . Who We Are . How to Learn Deep Learning . Your Projects and Your Mindset . The Software: PyTorch, fastai, and Jupyter . Your First Model . Getting a GPU Deep Learning Server . Running Your First Notebook . from fastai.vision.all import * path = untar_data(URLs.PETS)/&#39;images&#39; def is_cat(x): return x[0].isupper() dls = ImageDataLoaders.from_name_func( path, get_image_files(path), valid_pct=0.2, seed=42, label_func=is_cat, item_tfms=Resize(224)) learn = cnn_learner(dls, resnet34, metrics=error_rate) learn.fine_tune(1) . epoch train_loss valid_loss error_rate time . 0 | 0.161300 | 0.021319 | 0.009472 | 00:33 | . epoch train_loss valid_loss error_rate time . 0 | 0.069097 | 0.040982 | 0.009472 | 00:43 | . Sidebar: This Book Was Written in Jupyter Notebooks . 1+1 . 2 . img = PILImage.create(image_cat()) img.to_thumb(192) . End sidebar . uploader = widgets.FileUpload() uploader . img = PILImage.create(uploader.data[0]) is_cat,_,probs = learn.predict(img) print(f&quot;Is this a cat?: {is_cat}.&quot;) print(f&quot;Probability it&#39;s a cat: {probs[1].item():.6f}&quot;) . NameError Traceback (most recent call last) &lt;ipython-input-13-37db1363ed76&gt; in &lt;module&gt; 1 img = PILImage.create(uploader.data[0]) -&gt; 2 is_cat,_,probs = learn.predict(img) 3 print(f&#34;Is this a cat?: {is_cat}.&#34;) 4 print(f&#34;Probability it&#39;s a cat: {probs[1].item():.6f}&#34;) NameError: name &#39;learn&#39; is not defined . What Is Machine Learning? . gv(&#39;&#39;&#39;program[shape=box3d width=1 height=0.7] inputs-&gt;program-&gt;results&#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G program program results results program&#45;&gt;results inputs inputs inputs&#45;&gt;program gv(&#39;&#39;&#39;model[shape=box3d width=1 height=0.7] inputs-&gt;model-&gt;results; weights-&gt;model&#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G model model results results model&#45;&gt;results inputs inputs inputs&#45;&gt;model weights weights weights&#45;&gt;model gv(&#39;&#39;&#39;ordering=in model[shape=box3d width=1 height=0.7] inputs-&gt;model-&gt;results; weights-&gt;model; results-&gt;performance performance-&gt;weights[constraint=false label=update]&#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G model model results results model&#45;&gt;results inputs inputs inputs&#45;&gt;model performance performance results&#45;&gt;performance weights weights weights&#45;&gt;model performance&#45;&gt;weights update gv(&#39;&#39;&#39;model[shape=box3d width=1 height=0.7] inputs-&gt;model-&gt;results&#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G model model results results model&#45;&gt;results inputs inputs inputs&#45;&gt;model What Is a Neural Network? . A Bit of Deep Learning Jargon . gv(&#39;&#39;&#39;ordering=in model[shape=box3d width=1 height=0.7 label=architecture] inputs-&gt;model-&gt;predictions; parameters-&gt;model; labels-&gt;loss; predictions-&gt;loss loss-&gt;parameters[constraint=false label=update]&#39;&#39;&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; G model architecture predictions predictions model&#45;&gt;predictions inputs inputs inputs&#45;&gt;model loss loss predictions&#45;&gt;loss parameters parameters parameters&#45;&gt;model labels labels labels&#45;&gt;loss loss&#45;&gt;parameters update Limitations Inherent To Machine Learning . From this picture we can now see some fundamental things about training a deep learning model: . A model cannot be created without data. | A model can only learn to operate on the patterns seen in the input data used to train it. | This learning approach only creates predictions, not recommended actions. | It&#39;s not enough to just have examples of input data; we need labels for that data too (e.g., pictures of dogs and cats aren&#39;t enough to train a model; we need a label for each one, saying which ones are dogs, and which are cats). | . Generally speaking, we&#39;ve seen that most organizations that say they don&#39;t have enough data, actually mean they don&#39;t have enough labeled data. If any organization is interested in doing something in practice with a model, then presumably they have some inputs they plan to run their model against. And presumably they&#39;ve been doing that some other way for a while (e.g., manually, or with some heuristic program), so they have data from those processes! For instance, a radiology practice will almost certainly have an archive of medical scans (since they need to be able to check how their patients are progressing over time), but those scans may not have structured labels containing a list of diagnoses or interventions (since radiologists generally create free-text natural language reports, not structured data). We&#39;ll be discussing labeling approaches a lot in this book, because it&#39;s such an important issue in practice. . Since these kinds of machine learning models can only make predictions (i.e., attempt to replicate labels), this can result in a significant gap between organizational goals and model capabilities. For instance, in this book you&#39;ll learn how to create a recommendation system that can predict what products a user might purchase. This is often used in e-commerce, such as to customize products shown on a home page by showing the highest-ranked items. But such a model is generally created by looking at a user and their buying history (inputs) and what they went on to buy or look at (labels), which means that the model is likely to tell you about products the user already has or already knows about, rather than new products that they are most likely to be interested in hearing about. That&#39;s very different to what, say, an expert at your local bookseller might do, where they ask questions to figure out your taste, and then tell you about authors or series that you&#39;ve never heard of before. . How Our Image Recognizer Works . What Our Image Recognizer Learned . Image Recognizers Can Tackle Non-Image Tasks . Jargon Recap . Deep Learning Is Not Just for Image Classification . path = untar_data(URLs.CAMVID_TINY) dls = SegmentationDataLoaders.from_label_func( path, bs=8, fnames = get_image_files(path/&quot;images&quot;), label_func = lambda o: path/&#39;labels&#39;/f&#39;{o.stem}_P{o.suffix}&#39;, codes = np.loadtxt(path/&#39;codes.txt&#39;, dtype=str) ) learn = unet_learner(dls, resnet34) learn.fine_tune(8) . epoch train_loss valid_loss time . 0 | 2.987978 | 2.480352 | 00:21 | . epoch train_loss valid_loss time . 0 | 2.158624 | 1.743689 | 00:23 | . 1 | 1.767877 | 1.964173 | 00:26 | . 2 | 1.643144 | 1.283908 | 00:25 | . 3 | 1.472303 | 1.108046 | 00:25 | . 4 | 1.320544 | 0.973587 | 00:25 | . 5 | 1.183503 | 0.858053 | 00:26 | . 6 | 1.073220 | 0.822954 | 00:26 | . 7 | 0.986720 | 0.817717 | 00:25 | . learn.show_results(max_n=6, figsize=(7,8)) . from fastai.text.all import * dls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid=&#39;test&#39;) learn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, metrics=accuracy) learn.fine_tune(4, 1e-2) . epoch train_loss valid_loss accuracy time . 0 | 0.809147 | 01:06 | . KeyboardInterrupt Traceback (most recent call last) &lt;ipython-input-17-5ab79cd5e866&gt; in &lt;module&gt; 3 dls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid=&#39;test&#39;) 4 learn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, metrics=accuracy) -&gt; 5 learn.fine_tune(4, 1e-2) /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/callback/schedule.py in fine_tune(self, epochs, base_lr, freeze_epochs, lr_mult, pct_start, div, **kwargs) 155 &#34;Fine tune with `freeze` for `freeze_epochs` then with `unfreeze` from `epochs` using discriminative LR&#34; 156 self.freeze() --&gt; 157 self.fit_one_cycle(freeze_epochs, slice(base_lr), pct_start=0.99, **kwargs) 158 base_lr /= 2 159 self.unfreeze() /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/callback/schedule.py in fit_one_cycle(self, n_epoch, lr_max, div, div_final, pct_start, wd, moms, cbs, reset_opt) 110 scheds = {&#39;lr&#39;: combined_cos(pct_start, lr_max/div, lr_max, lr_max/div_final), 111 &#39;mom&#39;: combined_cos(pct_start, *(self.moms if moms is None else moms))} --&gt; 112 self.fit(n_epoch, cbs=ParamScheduler(scheds)+L(cbs), reset_opt=reset_opt, wd=wd) 113 114 # Cell /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in fit(self, n_epoch, lr, wd, cbs, reset_opt) 203 self.opt.set_hypers(lr=self.lr if lr is None else lr) 204 self.n_epoch = n_epoch --&gt; 205 self._with_events(self._do_fit, &#39;fit&#39;, CancelFitException, self._end_cleanup) 206 207 def _end_cleanup(self): self.dl,self.xb,self.yb,self.pred,self.loss = None,(None,),(None,),None,None /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 152 153 def _with_events(self, f, event_type, ex, final=noop): --&gt; 154 try: self(f&#39;before_{event_type}&#39;) ;f() 155 except ex: self(f&#39;after_cancel_{event_type}&#39;) 156 finally: self(f&#39;after_{event_type}&#39;) ;final() /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _do_fit(self) 194 for epoch in range(self.n_epoch): 195 self.epoch=epoch --&gt; 196 self._with_events(self._do_epoch, &#39;epoch&#39;, CancelEpochException) 197 198 def fit(self, n_epoch, lr=None, wd=None, cbs=None, reset_opt=False): /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 152 153 def _with_events(self, f, event_type, ex, final=noop): --&gt; 154 try: self(f&#39;before_{event_type}&#39;) ;f() 155 except ex: self(f&#39;after_cancel_{event_type}&#39;) 156 finally: self(f&#39;after_{event_type}&#39;) ;final() /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _do_epoch(self) 188 189 def _do_epoch(self): --&gt; 190 self._do_epoch_train() 191 self._do_epoch_validate() 192 /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _do_epoch_train(self) 180 def _do_epoch_train(self): 181 self.dl = self.dls.train --&gt; 182 self._with_events(self.all_batches, &#39;train&#39;, CancelTrainException) 183 184 def _do_epoch_validate(self, ds_idx=1, dl=None): /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 152 153 def _with_events(self, f, event_type, ex, final=noop): --&gt; 154 try: self(f&#39;before_{event_type}&#39;) ;f() 155 except ex: self(f&#39;after_cancel_{event_type}&#39;) 156 finally: self(f&#39;after_{event_type}&#39;) ;final() /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in all_batches(self) 158 def all_batches(self): 159 self.n_iter = len(self.dl) --&gt; 160 for o in enumerate(self.dl): self.one_batch(*o) 161 162 def _do_one_batch(self): /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in one_batch(self, i, b) 176 self.iter = i 177 self._split(b) --&gt; 178 self._with_events(self._do_one_batch, &#39;batch&#39;, CancelBatchException) 179 180 def _do_epoch_train(self): /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 152 153 def _with_events(self, f, event_type, ex, final=noop): --&gt; 154 try: self(f&#39;before_{event_type}&#39;) ;f() 155 except ex: self(f&#39;after_cancel_{event_type}&#39;) 156 finally: self(f&#39;after_{event_type}&#39;) ;final() /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/learner.py in _do_one_batch(self) 161 162 def _do_one_batch(self): --&gt; 163 self.pred = self.model(*self.xb) 164 self(&#39;after_pred&#39;) 165 if len(self.yb): self.loss = self.loss_func(self.pred, *self.yb) /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/module.py in _call_impl(self, *input, **kwargs) 725 result = self._slow_forward(*input, **kwargs) 726 else: --&gt; 727 result = self.forward(*input, **kwargs) 728 for hook in itertools.chain( 729 _global_forward_hooks.values(), /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/container.py in forward(self, input) 115 def forward(self, input): 116 for module in self: --&gt; 117 input = module(input) 118 return input 119 /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/module.py in _call_impl(self, *input, **kwargs) 725 result = self._slow_forward(*input, **kwargs) 726 else: --&gt; 727 result = self.forward(*input, **kwargs) 728 for hook in itertools.chain( 729 _global_forward_hooks.values(), /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/text/models/core.py in forward(self, input) 79 #Note: this expects that sequence really begins on a round multiple of bptt 80 real_bs = (input[:,i] != self.pad_idx).long().sum() &gt; 81 o = self.module(input[:real_bs,i: min(i+self.bptt, sl)]) 82 if self.max_len is None or sl-i &lt;= self.max_len: 83 outs.append(o) /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/module.py in _call_impl(self, *input, **kwargs) 725 result = self._slow_forward(*input, **kwargs) 726 else: --&gt; 727 result = self.forward(*input, **kwargs) 728 for hook in itertools.chain( 729 _global_forward_hooks.values(), /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/text/models/awdlstm.py in forward(self, inp, from_embeds) 104 new_hidden = [] 105 for l, (rnn,hid_dp) in enumerate(zip(self.rnns, self.hidden_dps)): --&gt; 106 output, new_h = rnn(output, self.hidden[l]) 107 new_hidden.append(new_h) 108 if l != self.n_layers - 1: output = hid_dp(output) /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/module.py in _call_impl(self, *input, **kwargs) 725 result = self._slow_forward(*input, **kwargs) 726 else: --&gt; 727 result = self.forward(*input, **kwargs) 728 for hook in itertools.chain( 729 _global_forward_hooks.values(), /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/text/models/awdlstm.py in forward(self, *args) 51 # To avoid the warning that comes because the weights aren&#39;t flattened. 52 warnings.simplefilter(&#34;ignore&#34;, category=UserWarning) &gt; 53 return self.module(*args) 54 55 def reset(self): /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/module.py in _call_impl(self, *input, **kwargs) 725 result = self._slow_forward(*input, **kwargs) 726 else: --&gt; 727 result = self.forward(*input, **kwargs) 728 for hook in itertools.chain( 729 _global_forward_hooks.values(), /opt/conda/envs/fastai/lib/python3.8/site-packages/torch/nn/modules/rnn.py in forward(self, input, hx) 579 self.check_forward_args(input, hx, batch_sizes) 580 if batch_sizes is None: --&gt; 581 result = _VF.lstm(input, hx, self._flat_weights, self.bias, self.num_layers, 582 self.dropout, self.training, self.bidirectional, self.batch_first) 583 else: /opt/conda/envs/fastai/lib/python3.8/site-packages/fastai/torch_core.py in __torch_function__(self, func, types, args, kwargs) 315 316 def __torch_function__(self, func, types, args=(), kwargs=None): --&gt; 317 with torch._C.DisableTorchFunction(): ret = _convert(func(*args, **(kwargs or {})), self.__class__) 318 if isinstance(ret, TensorBase): ret.set_meta(self, as_copy=True) 319 return ret KeyboardInterrupt: . If you hit a &quot;CUDA out of memory error&quot; after running this cell, click on the menu Kernel, then restart. Instead of executing the cell above, copy and paste the following code in it: . from fastai.text.all import * dls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid=&#39;test&#39;, bs=32) learn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, metrics=accuracy) learn.fine_tune(4, 1e-2) . This reduces the batch size to 32 (we will explain this later). If you keep hitting the same error, change 32 to 16. . learn.predict(&quot;I really liked that movie!&quot;) . (&#39;neg&#39;, TensorText(0), TensorText([0.5623, 0.4377])) . Sidebar: The Order Matters . End sidebar . from fastai.tabular.all import * path = untar_data(URLs.ADULT_SAMPLE) dls = TabularDataLoaders.from_csv(path/&#39;adult.csv&#39;, path=path, y_names=&quot;salary&quot;, cat_names = [&#39;workclass&#39;, &#39;education&#39;, &#39;marital-status&#39;, &#39;occupation&#39;, &#39;relationship&#39;, &#39;race&#39;], cont_names = [&#39;age&#39;, &#39;fnlwgt&#39;, &#39;education-num&#39;], procs = [Categorify, FillMissing, Normalize]) learn = tabular_learner(dls, metrics=accuracy) . learn.fit_one_cycle(3) . epoch train_loss valid_loss accuracy time . 0 | 0.367843 | 0.357764 | 0.832924 | 00:07 | . 1 | 0.362614 | 0.354566 | 0.831849 | 00:07 | . 2 | 0.344427 | 0.349152 | 0.837838 | 00:08 | . from fastai.collab import * path = untar_data(URLs.ML_SAMPLE) dls = CollabDataLoaders.from_csv(path/&#39;ratings.csv&#39;) learn = collab_learner(dls, y_range=(0.5,5.5)) learn.fine_tune(20) . epoch train_loss valid_loss time . 0 | 1.523609 | 1.353591 | 00:00 | . epoch train_loss valid_loss time . 0 | 1.377288 | 1.306087 | 00:00 | . 1 | 1.314181 | 1.222488 | 00:00 | . 2 | 1.191319 | 1.065583 | 00:00 | . 3 | 1.010563 | 0.854901 | 00:00 | . 4 | 0.818294 | 0.725766 | 00:00 | . 5 | 0.699861 | 0.688180 | 00:00 | . 6 | 0.650566 | 0.677446 | 00:00 | . 7 | 0.629411 | 0.673032 | 00:00 | . 8 | 0.609606 | 0.668113 | 00:00 | . 9 | 0.606750 | 0.663429 | 00:00 | . 10 | 0.594681 | 0.660590 | 00:00 | . 11 | 0.583541 | 0.656942 | 00:00 | . 12 | 0.574227 | 0.654432 | 00:00 | . 13 | 0.567019 | 0.651633 | 00:00 | . 14 | 0.548985 | 0.650612 | 00:00 | . 15 | 0.544749 | 0.649310 | 00:00 | . 16 | 0.542530 | 0.648421 | 00:00 | . 17 | 0.546451 | 0.648087 | 00:00 | . 18 | 0.544443 | 0.647970 | 00:00 | . 19 | 0.539262 | 0.647940 | 00:00 | . learn.show_results() . userId movieId rating rating_pred . 0 83.0 | 64.0 | 3.5 | 3.697940 | . 1 27.0 | 42.0 | 3.0 | 3.154352 | . 2 73.0 | 48.0 | 4.0 | 3.848425 | . 3 80.0 | 31.0 | 3.5 | 3.996437 | . 4 12.0 | 13.0 | 4.0 | 3.767331 | . 5 30.0 | 20.0 | 3.0 | 4.216630 | . 6 85.0 | 58.0 | 5.0 | 4.794383 | . 7 27.0 | 54.0 | 2.5 | 4.053595 | . 8 66.0 | 44.0 | 4.0 | 3.077837 | . Sidebar: Datasets: Food for Models . End sidebar . Validation Sets and Test Sets . Use Judgment in Defining Test Sets . A Choose Your Own Adventure moment . Questionnaire . It can be hard to know in pages and pages of prose what the key things are that you really need to focus on and remember. So, we&#39;ve prepared a list of questions and suggested steps to complete at the end of each chapter. All the answers are in the text of the chapter, so if you&#39;re not sure about anything here, reread that part of the text and make sure you understand it. Answers to all these questions are also available on the book&#39;s website. You can also visit the forums if you get stuck to get help from other folks studying this material. . For more questions, including detailed answers and links to the video timeline, have a look at Radek Osmulski&#39;s aiquizzes. . Do you need these for deep learning? . Lots of math T / F | Lots of data T / F | Lots of expensive computers T / F | A PhD T / F | . | Name five areas where deep learning is now the best in the world. . | What was the name of the first device that was based on the principle of the artificial neuron? | Based on the book of the same name, what are the requirements for parallel distributed processing (PDP)? | What were the two theoretical misunderstandings that held back the field of neural networks? | What is a GPU? | Open a notebook and execute a cell containing: 1+1. What happens? | Follow through each cell of the stripped version of the notebook for this chapter. Before executing each cell, guess what will happen. | Complete the Jupyter Notebook online appendix. | Why is it hard to use a traditional computer program to recognize images in a photo? | What did Samuel mean by &quot;weight assignment&quot;? | What term do we normally use in deep learning for what Samuel called &quot;weights&quot;? | Draw a picture that summarizes Samuel&#39;s view of a machine learning model. | Why is it hard to understand why a deep learning model makes a particular prediction? | What is the name of the theorem that shows that a neural network can solve any mathematical problem to any level of accuracy? | What do you need in order to train a model? | How could a feedback loop impact the rollout of a predictive policing model? | Do we always have to use 224×224-pixel images with the cat recognition model? | What is the difference between classification and regression? | What is a validation set? What is a test set? Why do we need them? | What will fastai do if you don&#39;t provide a validation set? | Can we always use a random sample for a validation set? Why or why not? | What is overfitting? Provide an example. | What is a metric? How does it differ from &quot;loss&quot;? | How can pretrained models help? | What is the &quot;head&quot; of a model? | What kinds of features do the early layers of a CNN find? How about the later layers? | Are image models only useful for photos? | What is an &quot;architecture&quot;? | What is segmentation? | What is y_range used for? When do we need it? | What are &quot;hyperparameters&quot;? | What&#39;s the best way to avoid failures when using AI in an organization? | Further Research . Each chapter also has a &quot;Further Research&quot; section that poses questions that aren&#39;t fully answered in the text, or gives more advanced assignments. Answers to these questions aren&#39;t on the book&#39;s website; you&#39;ll need to do your own research! . Why is a GPU useful for deep learning? How is a CPU different, and why is it less effective for deep learning? | Try to think of three areas where feedback loops might impact the use of machine learning. See if you can find documented examples of that happening in practice. |",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/ai/fastai/coursenotes/2021/01/06/fastai-01_intro.html",
            "relUrl": "/jupyter/ai/fastai/coursenotes/2021/01/06/fastai-01_intro.html",
            "date": " • Jan 6, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://chrismilleruk.github.io/fastpages/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://chrismilleruk.github.io/fastpages/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi! My name is Chris :rocket: . That’s all you need to know for now, but I’ll put more here later. . Find me online using the links in the footer or see some recent tweets: . Tweets by chrismilleruk btw. this website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://chrismilleruk.github.io/fastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://chrismilleruk.github.io/fastpages/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}